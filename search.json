[{"title":"Go六边形架构实践指南","url":"https://blog.ranchocooper.com/2025/03/20/go-hexagonal/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"Go六边形架构实践指南：构建可维护、可测试的微服务\"><a href=\"#Go六边形架构实践指南：构建可维护、可测试的微服务\" class=\"headerlink\" title=\"Go六边形架构实践指南：构建可维护、可测试的微服务\"></a>Go六边形架构实践指南：构建可维护、可测试的微服务</h1><p><img src=\"https://github.com/Sairyss/domain-driven-hexagon/raw/master/assets/images/DomainDrivenHexagon.png\" alt=\"六边形架构\"></p>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1. 引言\"></a>1. 引言</h2><p>在构建现代微服务架构时，代码的可维护性、可测试性和灵活性至关重要。六边形架构（Hexagonal Architecture，也称为端口与适配器架构）提供了一种优雅的解决方案，它将业务逻辑与技术实现细节分离，通过定义明确的边界使系统更加模块化。</p>\n<p>本文将通过一个实际的Go项目，详细介绍六边形架构的实现方式，展示如何构建一个遵循领域驱动设计(DDD)和依赖倒置原则(DIP)的微服务框架。</p>\n<h2 id=\"2-六边形架构概述\"><a href=\"#2-六边形架构概述\" class=\"headerlink\" title=\"2. 六边形架构概述\"></a>2. 六边形架构概述</h2><h3 id=\"2-1-核心理念\"><a href=\"#2-1-核心理念\" class=\"headerlink\" title=\"2.1 核心理念\"></a>2.1 核心理念</h3><p>六边形架构的核心思想是将应用程序分为内部(内核)和外部(适配器)两部分，通过定义良好的接口(端口)来连接它们。这种设计有以下特点：</p>\n<ol>\n<li><strong>业务逻辑独立</strong>：核心业务逻辑不依赖于外部系统（如数据库、HTTP等）</li>\n<li><strong>依赖倒置</strong>：依赖关系指向内部，外部依赖于内部接口而非实现</li>\n<li><strong>可替换性</strong>：外部组件可以被轻松替换，不影响核心业务逻辑</li>\n<li><strong>可测试性</strong>：业务逻辑可以独立测试，不需要外部依赖</li>\n</ol>\n<h3 id=\"2-2-架构层次\"><a href=\"#2-2-架构层次\" class=\"headerlink\" title=\"2.2 架构层次\"></a>2.2 架构层次</h3><p>我们的Go微服务框架分为以下几个核心层次：</p>\n<ol>\n<li>**领域层(Domain Layer)**：包含业务实体、值对象、领域服务和存储库接口</li>\n<li>**应用层(Application Layer)**：协调领域对象完成用例，处理事务边界</li>\n<li>**适配器层(Adapter Layer)**：实现与外部系统的交互，如数据库、消息队列等</li>\n<li>**API层(API Layer)**：处理HTTP&#x2F;gRPC请求，数据验证和转换</li>\n</ol>\n<h2 id=\"3-项目结构\"><a href=\"#3-项目结构\" class=\"headerlink\" title=\"3. 项目结构\"></a>3. 项目结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go-hexagonal/</span><br><span class=\"line\">├── adapter/                # 适配器层 - 外部系统交互</span><br><span class=\"line\">│   ├── repository/         # 仓储实现</span><br><span class=\"line\">│   ├── dependency/         # 依赖注入配置</span><br><span class=\"line\">│   ├── job/                # 定时任务</span><br><span class=\"line\">│   └── amqp/               # 消息队列</span><br><span class=\"line\">├── api/                    # API层 - HTTP/gRPC请求处理</span><br><span class=\"line\">│   ├── http/               # HTTP处理器</span><br><span class=\"line\">│   ├── grpc/               # gRPC处理器</span><br><span class=\"line\">│   ├── error_code/         # 错误码定义</span><br><span class=\"line\">│   └── dto/                # 数据传输对象</span><br><span class=\"line\">├── application/            # 应用层 - 用例协调</span><br><span class=\"line\">│   └── example/            # 示例用例实现</span><br><span class=\"line\">├── domain/                 # 领域层 - 核心业务逻辑</span><br><span class=\"line\">│   ├── service/            # 领域服务</span><br><span class=\"line\">│   ├── repo/               # 仓储接口</span><br><span class=\"line\">│   ├── event/              # 领域事件</span><br><span class=\"line\">│   ├── vo/                 # 值对象</span><br><span class=\"line\">│   ├── model/              # 领域模型</span><br><span class=\"line\">│   └── aggregate/          # 聚合根</span><br><span class=\"line\">├── cmd/                    # 应用程序入口</span><br><span class=\"line\">├── config/                 # 配置</span><br><span class=\"line\">└── tests/                  # 测试</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-领域层实现\"><a href=\"#4-领域层实现\" class=\"headerlink\" title=\"4. 领域层实现\"></a>4. 领域层实现</h2><p>领域层是应用程序的核心，包含业务实体和业务规则，不依赖于外部系统。</p>\n<h3 id=\"4-1-领域模型\"><a href=\"#4-1-领域模型\" class=\"headerlink\" title=\"4.1 领域模型\"></a>4.1 领域模型</h3><p>领域模型定义了业务实体，例如我们的<code>Example</code>模型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain/model/example.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> model</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Example represents a basic example entity</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Example <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Id        <span class=\"type\">int</span>       <span class=\"string\">`json:&quot;id&quot; gorm:&quot;column:id;primaryKey;autoIncrement&quot; structs:&quot;,omitempty,underline&quot;`</span></span><br><span class=\"line\">    Name      <span class=\"type\">string</span>    <span class=\"string\">`json:&quot;name&quot; gorm:&quot;column:name;type:varchar(255);not null&quot; structs:&quot;,omitempty,underline&quot;`</span></span><br><span class=\"line\">    Alias     <span class=\"type\">string</span>    <span class=\"string\">`json:&quot;alias&quot; gorm:&quot;column:alias;type:varchar(255)&quot; structs:&quot;,omitempty,underline&quot;`</span></span><br><span class=\"line\">    CreatedAt time.Time <span class=\"string\">`json:&quot;created_at&quot; gorm:&quot;column:created_at;autoCreateTime&quot; structs:&quot;,omitempty,underline&quot;`</span></span><br><span class=\"line\">    UpdatedAt time.Time <span class=\"string\">`json:&quot;updated_at&quot; gorm:&quot;column:updated_at;autoUpdateTime&quot; structs:&quot;,omitempty,underline&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TableName returns the table name for the Example model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Example)</span></span> TableName() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;example&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-仓储接口\"><a href=\"#4-2-仓储接口\" class=\"headerlink\" title=\"4.2 仓储接口\"></a>4.2 仓储接口</h3><p>仓储接口定义了对领域模型的持久化操作，遵循依赖倒置原则：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain/repo/example.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/model&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IExampleRepo defines the interface for example repository</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IExampleRepo <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Create(ctx context.Context, tr Transaction, example *model.Example) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\">    Delete(ctx context.Context, tr Transaction, id <span class=\"type\">int</span>) <span class=\"type\">error</span></span><br><span class=\"line\">    Update(ctx context.Context, tr Transaction, entity *model.Example) <span class=\"type\">error</span></span><br><span class=\"line\">    GetByID(ctx context.Context, tr Transaction, Id <span class=\"type\">int</span>) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\">    FindByName(ctx context.Context, tr Transaction, name <span class=\"type\">string</span>) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IExampleCacheRepo defines the interface for example cache repository</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IExampleCacheRepo <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    HealthCheck(ctx context.Context) <span class=\"type\">error</span></span><br><span class=\"line\">    GetByID(ctx context.Context, id <span class=\"type\">int</span>) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\">    GetByName(ctx context.Context, name <span class=\"type\">string</span>) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\">    Set(ctx context.Context, example *model.Example) <span class=\"type\">error</span></span><br><span class=\"line\">    Delete(ctx context.Context, id <span class=\"type\">int</span>) <span class=\"type\">error</span></span><br><span class=\"line\">    Invalidate(ctx context.Context) <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-领域服务接口\"><a href=\"#4-3-领域服务接口\" class=\"headerlink\" title=\"4.3 领域服务接口\"></a>4.3 领域服务接口</h3><p>领域服务接口定义了业务操作，作为应用层与领域层之间的契约：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain/service/iexample_service.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/model&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IExampleService defines the interface for example service</span></span><br><span class=\"line\"><span class=\"comment\">// This allows the application layer to depend on interfaces rather than concrete implementations,</span></span><br><span class=\"line\"><span class=\"comment\">// facilitating testing and adhering to the dependency inversion principle</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IExampleService <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create creates a new example</span></span><br><span class=\"line\">    Create(ctx context.Context, example *model.Example) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Delete deletes an example by ID</span></span><br><span class=\"line\">    Delete(ctx context.Context, id <span class=\"type\">int</span>) <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Update updates an example</span></span><br><span class=\"line\">    Update(ctx context.Context, example *model.Example) <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get retrieves an example by ID</span></span><br><span class=\"line\">    Get(ctx context.Context, id <span class=\"type\">int</span>) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// FindByName finds examples by name</span></span><br><span class=\"line\">    FindByName(ctx context.Context, name <span class=\"type\">string</span>) (*model.Example, <span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-领域服务实现\"><a href=\"#4-4-领域服务实现\" class=\"headerlink\" title=\"4.4 领域服务实现\"></a>4.4 领域服务实现</h3><p>领域服务实现包含具体的业务逻辑：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain/service/example.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/event&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/model&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/repo&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/util/log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ExampleService handles business logic for Example entity</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ExampleService <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Repository repo.IExampleRepo</span><br><span class=\"line\">    EventBus   event.EventBus</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewExampleService creates a new example service instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewExampleService</span><span class=\"params\">(repository repo.IExampleRepo)</span></span> *ExampleService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;ExampleService&#123;</span><br><span class=\"line\">        Repository: repository,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create creates a new example</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ExampleService)</span></span> Create(ctx context.Context, example *model.Example) (*model.Example, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a no-operation transaction</span></span><br><span class=\"line\">    tr := repo.NewNoopTransaction(s.Repository)</span><br><span class=\"line\"></span><br><span class=\"line\">    createdExample, err := s.Repository.Create(ctx, tr, example)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.SugaredLogger.Errorf(<span class=\"string\">&quot;Failed to create example: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;failed to create example: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Publish event if event bus is available</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.EventBus != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        evt := event.NewExampleCreatedEvent(createdExample.Id, createdExample.Name, createdExample.Alias)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err := s.EventBus.Publish(ctx, evt); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.SugaredLogger.Warnf(<span class=\"string\">&quot;Failed to publish event: %v&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createdExample, fmt.Errorf(<span class=\"string\">&quot;failed to publish example created event: %w&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> createdExample, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他方法实现...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-5-领域事件\"><a href=\"#4-5-领域事件\" class=\"headerlink\" title=\"4.5 领域事件\"></a>4.5 领域事件</h3><p>领域事件是领域层中的重要概念，用于解耦领域操作和副作用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain/event/event_bus.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> event</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventHandler defines the event handler interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> EventHandler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// HandleEvent processes an event</span></span><br><span class=\"line\">    HandleEvent(ctx context.Context, event Event) <span class=\"type\">error</span></span><br><span class=\"line\">    <span class=\"comment\">// InterestedIn checks if the handler is interested in the event</span></span><br><span class=\"line\">    InterestedIn(eventName <span class=\"type\">string</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EventBus defines the event bus interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> EventBus <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Publish publishes an event</span></span><br><span class=\"line\">    Publish(ctx context.Context, event Event) <span class=\"type\">error</span></span><br><span class=\"line\">    <span class=\"comment\">// Subscribe registers an event handler</span></span><br><span class=\"line\">    Subscribe(handler EventHandler)</span><br><span class=\"line\">    <span class=\"comment\">// Unsubscribe removes an event handler</span></span><br><span class=\"line\">    Unsubscribe(handler EventHandler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InMemoryEventBus implements an in-memory event bus</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> InMemoryEventBus <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    handlers []EventHandler</span><br><span class=\"line\">    mu       sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewInMemoryEventBus creates a new in-memory event bus</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewInMemoryEventBus</span><span class=\"params\">()</span></span> *InMemoryEventBus &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;InMemoryEventBus&#123;</span><br><span class=\"line\">        handlers: <span class=\"built_in\">make</span>([]EventHandler, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Publish publishes an event to all interested handlers</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *InMemoryEventBus)</span></span> Publish(ctx context.Context, event Event) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    b.mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> b.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, handler := <span class=\"keyword\">range</span> b.handlers &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> handler.InterestedIn(event.EventName()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err := handler.HandleEvent(ctx, event); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他方法实现...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-应用层实现\"><a href=\"#5-应用层实现\" class=\"headerlink\" title=\"5. 应用层实现\"></a>5. 应用层实现</h2><p>应用层协调领域对象来完成特定的用例，处理事务、安全性等横切关注点。</p>\n<h3 id=\"5-1-用例实现\"><a href=\"#5-1-用例实现\" class=\"headerlink\" title=\"5.1 用例实现\"></a>5.1 用例实现</h3><p>每个用例都是应用层中的一个具体操作，例如创建示例的用例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// application/example/create.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/repo&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/service&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CreateUseCase handles the create example use case</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> CreateUseCase <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    exampleService service.IExampleService</span><br><span class=\"line\">    converter      service.Converter</span><br><span class=\"line\">    txFactory      repo.TransactionFactory</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewCreateUseCase creates a new CreateUseCase instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCreateUseCase</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    exampleService service.IExampleService,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    converter service.Converter,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    txFactory repo.TransactionFactory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> *CreateUseCase &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;CreateUseCase&#123;</span><br><span class=\"line\">        exampleService: exampleService,</span><br><span class=\"line\">        converter:      converter,</span><br><span class=\"line\">        txFactory:      txFactory,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Execute processes the create example request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(uc *CreateUseCase)</span></span> Execute(ctx context.Context, input any) (any, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Convert input to domain model using the converter</span></span><br><span class=\"line\">    example, err := uc.converter.FromCreateRequest(input)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;failed to convert request: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create a real transaction for atomic operations</span></span><br><span class=\"line\">    tx, err := uc.txFactory.NewTransaction(ctx, repo.MySQLStore, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;failed to create transaction: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> tx.Rollback()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call domain service</span></span><br><span class=\"line\">    createdExample, err := uc.exampleService.Create(ctx, example)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;failed to create example: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Commit transaction</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = tx.Commit(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;failed to commit transaction: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert domain model to response using the converter</span></span><br><span class=\"line\">    result, err := uc.converter.ToExampleResponse(createdExample)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;failed to convert response: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-适配器层实现\"><a href=\"#6-适配器层实现\" class=\"headerlink\" title=\"6. 适配器层实现\"></a>6. 适配器层实现</h2><p>适配器层实现具体的技术细节，连接领域层与外部系统。</p>\n<h3 id=\"6-1-仓储实现\"><a href=\"#6-1-仓储实现\" class=\"headerlink\" title=\"6.1 仓储实现\"></a>6.1 仓储实现</h3><p>仓储实现提供了领域仓储接口的具体实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// adapter/repository/mysql/entity/example.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> entity</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/model&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/repo&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Example represents the MySQL implementation of IExampleRepo</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Example <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Database connection or any dependencies could be added here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewExample creates a new Example repository</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewExample</span><span class=\"params\">()</span></span> *Example &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Example&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create implements IExampleRepo.Create</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Example)</span></span> Create(ctx context.Context, tr repo.Transaction, example *model.Example) (*model.Example, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Implement actual database logic for creation</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> example, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GetByID implements IExampleRepo.GetByID</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Example)</span></span> GetByID(ctx context.Context, tr repo.Transaction, id <span class=\"type\">int</span>) (*model.Example, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Implement actual database logic for fetching</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;model.Example&#123;</span><br><span class=\"line\">        Id:        id,</span><br><span class=\"line\">        Name:      <span class=\"string\">&quot;Example from MySQL&quot;</span>,</span><br><span class=\"line\">        Alias:     <span class=\"string\">&quot;MySQL Demo&quot;</span>,</span><br><span class=\"line\">        CreatedAt: time.Now(),</span><br><span class=\"line\">        UpdatedAt: time.Now(),</span><br><span class=\"line\">    &#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他方法实现...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-缓存实现\"><a href=\"#6-2-缓存实现\" class=\"headerlink\" title=\"6.2 缓存实现\"></a>6.2 缓存实现</h3><p>增强型缓存实现，提供了高级缓存功能：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// adapter/repository/redis/enhanced_cache.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    apperrors <span class=\"string\">&quot;go-hexagonal/util/errors&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EnhancedCache provides advanced caching capabilities</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> EnhancedCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    client  *RedisClient</span><br><span class=\"line\">    options CacheOptions</span><br><span class=\"line\">    <span class=\"comment\">// Simple key tracking map</span></span><br><span class=\"line\">    trackedKeys <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">    keysMutex   sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewEnhancedCache creates a new enhanced cache instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewEnhancedCache</span><span class=\"params\">(client *RedisClient, options CacheOptions)</span></span> *EnhancedCache &#123;</span><br><span class=\"line\">    cache := &amp;EnhancedCache&#123;</span><br><span class=\"line\">        client:      client,</span><br><span class=\"line\">        options:     options,</span><br><span class=\"line\">        trackedKeys: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">struct</span>&#123;&#125;, options.MaxTrackedKeys),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TryGetSet tries to get a value from cache, if not found executes the loader and sets the result</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *EnhancedCache)</span></span> TryGetSet(ctx context.Context, key <span class=\"type\">string</span>, dest <span class=\"keyword\">interface</span>&#123;&#125;, ttl time.Duration, loader <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Try to get from cache first</span></span><br><span class=\"line\">    err := c.Get(ctx, key, dest)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache hit, return success</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If it&#x27;s not a NotFound error, return the error</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !apperrors.IsNotFoundError(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute within a lock to prevent cache stampede</span></span><br><span class=\"line\">    lockKey := <span class=\"string\">&quot;lock:&quot;</span> + key</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c.WithLock(ctx, lockKey, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Try to get again (might have been set by another process while waiting for lock)</span></span><br><span class=\"line\">        err := c.Get(ctx, key, dest)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Cache hit, return success</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If it&#x27;s not a NotFound error, return the error</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> !apperrors.IsNotFoundError(err) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Execute the loader</span></span><br><span class=\"line\">        result, err := loader()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If loader failed, set negative cache if enabled</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> c.options.EnableNegativeCache &#123;</span><br><span class=\"line\">                _ = c.SetNegative(ctx, key)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If nil result, set negative cache</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c.options.EnableNegativeCache &#123;</span><br><span class=\"line\">                _ = c.SetNegative(ctx, key)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> apperrors.New(apperrors.ErrorTypeNotFound, <span class=\"string\">&quot;loader returned nil result&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set the value in cache</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err := c.Set(ctx, key, result, ttl); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Convert the result back to the destination</span></span><br><span class=\"line\">        resultBytes, err := json.Marshal(result)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> apperrors.Wrapf(err, apperrors.ErrorTypeSystem, <span class=\"string\">&quot;failed to marshal loader result&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> json.Unmarshal(resultBytes, dest)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他方法实现...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-API层实现\"><a href=\"#7-API层实现\" class=\"headerlink\" title=\"7. API层实现\"></a>7. API层实现</h2><p>API层负责处理HTTP请求和响应，是系统与外部世界交互的入口。</p>\n<h3 id=\"7-1-HTTP处理器\"><a href=\"#7-1-HTTP处理器\" class=\"headerlink\" title=\"7.1 HTTP处理器\"></a>7.1 HTTP处理器</h3><p>HTTP处理器处理来自客户端的HTTP请求：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// api/http/handle/handle.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> handle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/api/dto&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/api/error_code&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/api/http/paginate&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/util/log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// StandardResponse defines the standard API response structure</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> StandardResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Code    <span class=\"type\">int</span>         <span class=\"string\">`json:&quot;code&quot;`</span>              <span class=\"comment\">// Status code</span></span><br><span class=\"line\">    Message <span class=\"type\">string</span>      <span class=\"string\">`json:&quot;message&quot;`</span>           <span class=\"comment\">// Response message</span></span><br><span class=\"line\">    Data    <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:&quot;data,omitempty&quot;`</span>    <span class=\"comment\">// Response data</span></span><br><span class=\"line\">    DocRef  <span class=\"type\">string</span>      <span class=\"string\">`json:&quot;doc_ref,omitempty&quot;`</span> <span class=\"comment\">// Documentation reference</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Success returns a success response</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Success</span><span class=\"params\">(c *gin.Context, data any)</span></span> &#123;</span><br><span class=\"line\">    c.JSON(http.StatusOK, StandardResponse&#123;</span><br><span class=\"line\">        Code:    <span class=\"number\">0</span>,</span><br><span class=\"line\">        Message: <span class=\"string\">&quot;success&quot;</span>,</span><br><span class=\"line\">        Data:    data,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error unified error handling</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Error</span><span class=\"params\">(c *gin.Context, err <span class=\"type\">error</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Handle API error codes</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> apiErr, ok := err.(*error_code.Error); ok &#123;</span><br><span class=\"line\">        c.JSON(apiErr.StatusCode(), StandardResponse&#123;</span><br><span class=\"line\">            Code:    apiErr.Code,</span><br><span class=\"line\">            Message: apiErr.Msg,</span><br><span class=\"line\">            Data:    gin.H&#123;<span class=\"string\">&quot;details&quot;</span>: apiErr.Details&#125;,</span><br><span class=\"line\">            DocRef:  apiErr.DocRef,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Log unexpected errors</span></span><br><span class=\"line\">    log.SugaredLogger.Errorf(<span class=\"string\">&quot;Unexpected error: %v&quot;</span>, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Default error response</span></span><br><span class=\"line\">    c.JSON(http.StatusInternalServerError, StandardResponse&#123;</span><br><span class=\"line\">        Code:    error_code.ServerErrorCode,</span><br><span class=\"line\">        Message: <span class=\"string\">&quot;Internal server error&quot;</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他方法实现...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-错误处理\"><a href=\"#8-错误处理\" class=\"headerlink\" title=\"8. 错误处理\"></a>8. 错误处理</h2><p>一致的错误处理是良好架构设计的重要部分：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// api/error_code/error_code.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> error_code</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error represents a standardized API error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Error <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Code    <span class=\"type\">int</span>      <span class=\"string\">`json:&quot;code&quot;`</span>              <span class=\"comment\">// Error code</span></span><br><span class=\"line\">    Msg     <span class=\"type\">string</span>   <span class=\"string\">`json:&quot;message&quot;`</span>           <span class=\"comment\">// Error message</span></span><br><span class=\"line\">    Details []<span class=\"type\">string</span> <span class=\"string\">`json:&quot;details,omitempty&quot;`</span> <span class=\"comment\">// Optional error details</span></span><br><span class=\"line\">    HTTP    <span class=\"type\">int</span>      <span class=\"string\">`json:&quot;-&quot;`</span>                 <span class=\"comment\">// HTTP status code (not exposed in JSON)</span></span><br><span class=\"line\">    DocRef  <span class=\"type\">string</span>   <span class=\"string\">`json:&quot;doc_ref,omitempty&quot;`</span> <span class=\"comment\">// Reference to documentation</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewError creates a new Error instance with the specified code and message</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewError</span><span class=\"params\">(code <span class=\"type\">int</span>, msg <span class=\"type\">string</span>)</span></span> *Error &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := codes[code]; ok &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(fmt.Sprintf(<span class=\"string\">&quot;error code %d already exists, please replace one&quot;</span>, code))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    codes[code] = msg</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Error&#123;</span><br><span class=\"line\">        Code: code,</span><br><span class=\"line\">        Msg:  msg,</span><br><span class=\"line\">        HTTP: determineHTTPStatusCode(code), <span class=\"comment\">// Determine default HTTP status code</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WithDetails adds error details</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Error)</span></span> WithDetails(details ...<span class=\"type\">string</span>) *Error &#123;</span><br><span class=\"line\">    newError := *e</span><br><span class=\"line\">    newError.Details = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">    newError.Details = <span class=\"built_in\">append</span>(newError.Details, details...)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;newError</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error implements the error interface</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Error)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;err_code: %d, err_msg: %s, details: %v&quot;</span>, e.Code, e.Msg, e.Details)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他方法实现...</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-依赖注入\"><a href=\"#9-依赖注入\" class=\"headerlink\" title=\"9. 依赖注入\"></a>9. 依赖注入</h2><p>依赖注入是六边形架构的重要支柱，我们使用Google Wire进行依赖注入：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// adapter/dependency/wire.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> dependency</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/google/wire&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/adapter/repository/mysql/entity&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/event&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/repo&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/service&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ProvideExampleService creates and returns an ExampleService</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ProvideExampleService</span><span class=\"params\">(repo repo.IExampleRepo, eventBus event.EventBus)</span></span> service.IExampleService &#123;</span><br><span class=\"line\">    svc := service.NewExampleService(repo)</span><br><span class=\"line\">    svc.EventBus = eventBus</span><br><span class=\"line\">    <span class=\"keyword\">return</span> svc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ProvideExampleRepository creates and returns an Example repository</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ProvideExampleRepository</span><span class=\"params\">()</span></span> repo.IExampleRepo &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entity.NewExample()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ProvideEventBus creates and returns an event bus</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ProvideEventBus</span><span class=\"params\">()</span></span> event.EventBus &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> event.NewInMemoryEventBus()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InitializeDependencies initializes all dependencies</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitializeDependencies</span><span class=\"params\">()</span></span> (service.IExampleService, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    wire.Build(</span><br><span class=\"line\">        ProvideExampleRepository,</span><br><span class=\"line\">        ProvideEventBus,</span><br><span class=\"line\">        ProvideExampleService,</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-测试策略\"><a href=\"#10-测试策略\" class=\"headerlink\" title=\"10. 测试策略\"></a>10. 测试策略</h2><p>六边形架构的一个重要优势是可测试性，让我们来看看如何进行不同层次的测试。</p>\n<h3 id=\"10-1-领域层测试\"><a href=\"#10-1-领域层测试\" class=\"headerlink\" title=\"10.1 领域层测试\"></a>10.1 领域层测试</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain/service/example_test.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> service_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/mock&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/model&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/service&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/repo&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/mocks&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestExampleService_Create</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建模拟仓储</span></span><br><span class=\"line\">    mockRepo := &amp;mocks.MockExampleRepo&#123;&#125;</span><br><span class=\"line\">    mockEventBus := &amp;mocks.MockEventBus&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置期望行为</span></span><br><span class=\"line\">    mockRepo.On(<span class=\"string\">&quot;Create&quot;</span>, mock.Anything, mock.Anything, mock.AnythingOfType(<span class=\"string\">&quot;*model.Example&quot;</span>)).</span><br><span class=\"line\">        Return(&amp;model.Example&#123;Id: <span class=\"number\">1</span>, Name: <span class=\"string\">&quot;Test&quot;</span>&#125;, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    mockEventBus.On(<span class=\"string\">&quot;Publish&quot;</span>, mock.Anything, mock.Anything).Return(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建服务</span></span><br><span class=\"line\">    exampleService := service.NewExampleService(mockRepo)</span><br><span class=\"line\">    exampleService.EventBus = mockEventBus</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行测试</span></span><br><span class=\"line\">    result, err := exampleService.Create(context.Background(), &amp;model.Example&#123;Name: <span class=\"string\">&quot;Test&quot;</span>&#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 验证结果</span></span><br><span class=\"line\">    assert.NoError(t, err)</span><br><span class=\"line\">    assert.Equal(t, <span class=\"number\">1</span>, result.Id)</span><br><span class=\"line\">    assert.Equal(t, <span class=\"string\">&quot;Test&quot;</span>, result.Name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 验证模拟调用</span></span><br><span class=\"line\">    mockRepo.AssertExpectations(t)</span><br><span class=\"line\">    mockEventBus.AssertExpectations(t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-2-应用层测试\"><a href=\"#10-2-应用层测试\" class=\"headerlink\" title=\"10.2 应用层测试\"></a>10.2 应用层测试</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// application/example/create_test.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> example_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/mock&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/application/example&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/domain/model&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;go-hexagonal/mocks&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUseCase_Execute</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建模拟依赖</span></span><br><span class=\"line\">    mockService := &amp;mocks.MockExampleService&#123;&#125;</span><br><span class=\"line\">    mockConverter := &amp;mocks.MockConverter&#123;&#125;</span><br><span class=\"line\">    mockTxFactory := &amp;mocks.MockTransactionFactory&#123;&#125;</span><br><span class=\"line\">    mockTx := &amp;mocks.MockTransaction&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置期望行为</span></span><br><span class=\"line\">    mockConverter.On(<span class=\"string\">&quot;FromCreateRequest&quot;</span>, mock.Anything).</span><br><span class=\"line\">        Return(&amp;model.Example&#123;Name: <span class=\"string\">&quot;Test&quot;</span>&#125;, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    mockTxFactory.On(<span class=\"string\">&quot;NewTransaction&quot;</span>, mock.Anything, mock.Anything, mock.Anything).</span><br><span class=\"line\">        Return(mockTx, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    mockService.On(<span class=\"string\">&quot;Create&quot;</span>, mock.Anything, mock.Anything).</span><br><span class=\"line\">        Return(&amp;model.Example&#123;Id: <span class=\"number\">1</span>, Name: <span class=\"string\">&quot;Test&quot;</span>&#125;, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    mockTx.On(<span class=\"string\">&quot;Commit&quot;</span>).Return(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    mockTx.On(<span class=\"string\">&quot;Rollback&quot;</span>).Return(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    mockConverter.On(<span class=\"string\">&quot;ToExampleResponse&quot;</span>, mock.Anything).</span><br><span class=\"line\">        Return(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;Test&quot;</span>&#125;, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建用例</span></span><br><span class=\"line\">    useCase := example.NewCreateUseCase(mockService, mockConverter, mockTxFactory)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行测试</span></span><br><span class=\"line\">    result, err := useCase.Execute(context.Background(), <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;Test&quot;</span>&#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 验证结果</span></span><br><span class=\"line\">    assert.NoError(t, err)</span><br><span class=\"line\">    assert.Equal(t, <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;Test&quot;</span>&#125;, result)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 验证模拟调用</span></span><br><span class=\"line\">    mockService.AssertExpectations(t)</span><br><span class=\"line\">    mockConverter.AssertExpectations(t)</span><br><span class=\"line\">    mockTxFactory.AssertExpectations(t)</span><br><span class=\"line\">    mockTx.AssertExpectations(t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-高级特性\"><a href=\"#11-高级特性\" class=\"headerlink\" title=\"11. 高级特性\"></a>11. 高级特性</h2><h3 id=\"11-1-分布式锁与缓存防穿透\"><a href=\"#11-1-分布式锁与缓存防穿透\" class=\"headerlink\" title=\"11.1 分布式锁与缓存防穿透\"></a>11.1 分布式锁与缓存防穿透</h3><p>我们的Redis增强缓存实现了多种高级特性，包括分布式锁和缓存防穿透：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用分布式锁</span></span><br><span class=\"line\">err := cache.WithLock(ctx, <span class=\"string\">&quot;lock:resource&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 受分布式锁保护的代码</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> updateSharedResource()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动加载缓存的使用示例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result UserProfile</span><br><span class=\"line\">err := cache.TryGetSet(ctx, <span class=\"string\">&quot;user:profile:123&quot;</span>, &amp;result, <span class=\"number\">30</span>*time.Minute, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 仅在缓存未命中时执行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchUserProfileFromDatabase(<span class=\"number\">123</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-事件驱动架构\"><a href=\"#11-2-事件驱动架构\" class=\"headerlink\" title=\"11.2 事件驱动架构\"></a>11.2 事件驱动架构</h3><p>我们的事件系统支持同步和异步事件处理：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同步发布事件</span></span><br><span class=\"line\">err := eventBus.Publish(ctx, event.NewExampleCreatedEvent(example.Id, example.Name))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置异步事件总线</span></span><br><span class=\"line\">config := event.DefaultAsyncEventBusConfig()</span><br><span class=\"line\">config.QueueSize = <span class=\"number\">1000</span></span><br><span class=\"line\">config.WorkerCount = <span class=\"number\">10</span></span><br><span class=\"line\">asyncEventBus := event.NewAsyncEventBus(config)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步发布事件</span></span><br><span class=\"line\">err := asyncEventBus.Publish(ctx, event.NewExampleCreatedEvent(example.Id, example.Name))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优雅关闭</span></span><br><span class=\"line\">err := asyncEventBus.Close(<span class=\"number\">5</span> * time.Second)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-最佳实践与经验教训\"><a href=\"#12-最佳实践与经验教训\" class=\"headerlink\" title=\"12. 最佳实践与经验教训\"></a>12. 最佳实践与经验教训</h2><p>在实施六边形架构时，我们学到了一些宝贵的经验：</p>\n<ol>\n<li><strong>接口定义至关重要</strong>：良好定义的接口是六边形架构的基础，它们应该反映业务需求而非技术实现</li>\n<li><strong>依赖注入是必要的</strong>：使用依赖注入框架如Wire可以大幅简化组件组装</li>\n<li><strong>单一职责原则</strong>：每个组件应该只有一个变更理由，避免”上帝类”</li>\n<li><strong>测试驱动开发</strong>：六边形架构非常适合TDD，先写测试再写实现</li>\n<li><strong>避免领域污染</strong>：不要让技术细节（如ORM标签）污染领域模型</li>\n<li><strong>统一错误处理</strong>：使用一致的错误模型，区分业务错误和技术错误</li>\n</ol>\n<h2 id=\"13-结论\"><a href=\"#13-结论\" class=\"headerlink\" title=\"13. 结论\"></a>13. 结论</h2><p>六边形架构为构建可维护、可测试和灵活的Go微服务提供了一个强大的框架。通过明确的层次分离和依赖倒置，我们可以创建出更易于理解、扩展和</p>\n<blockquote>\n<p>本项目已在GitHub开源<a href=\"https://github.com/RanchoCooper/go-hexagonal\">Go-Hexagonal</a>，欢迎社区贡献和改进建议。</p>\n</blockquote>\n","categories":[],"tags":["六边形架构","领域驱动设计"]},{"title":"2021面试合集","url":"https://blog.ranchocooper.com/2021/08/28/interview-2021/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>八月份出去面试了一波，本文整理了上海一二线主流公司的面经(Golang后端)。</p>\n<h1 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h1><p>仅提供部分问题的答案，自行按需查阅资料。</p>\n<h2 id=\"B站\"><a href=\"#B站\" class=\"headerlink\" title=\"B站\"></a>B站</h2><h3 id=\"B站一面\"><a href=\"#B站一面\" class=\"headerlink\" title=\"B站一面\"></a>B站一面</h3><ul>\n<li>gRPC连接的四种模式<ul>\n<li>简单RPC</li>\n<li>服务端流式RPC</li>\n<li>客户端流式RPC</li>\n<li>双向流式RPC</li>\n</ul>\n</li>\n<li>如何做超时控制<ul>\n<li>context.WithTimeout&#x2F;context.WithDeadline + time.After</li>\n<li>context.WithTimeout&#x2F;context.WithDeadline + time.NewTimer</li>\n<li>channel + time.After&#x2F;time.NewTimer</li>\n</ul>\n</li>\n<li>context的实现机制</li>\n<li>Redis应用, 页面中有一个活动页的uv人数, 一般使用什么数据类型<ul>\n<li>set<ul>\n<li>压缩链表&#x2F;哈希表(去重)</li>\n</ul>\n</li>\n<li>zset<ul>\n<li>跳表(主要作用是提高检索效率, 里面的key值是哈希值) + 哈希(去重)</li>\n<li>压缩列表(数据量小的时候)</li>\n</ul>\n</li>\n<li>set获取当前元素个数的时间复杂度是多少<ul>\n<li>O(1)</li>\n</ul>\n</li>\n<li>如果使用bitmap来做去重和uv统计, 是否合理<ul>\n<li>位数不一定满足</li>\n<li>空间利用率可能不高</li>\n<li>统计的复杂度是O(N)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MySQL<ul>\n<li>用户表的建表语句, 包括索引&#x2F;字段定义</li>\n<li>uid的唯一约束</li>\n<li>select * from tb_user where uid &#x3D; xxx for update<ul>\n<li><ol>\n<li>uid存在</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>uid不存在, 间隙锁, 防止幻读的场景, 会锁表</li>\n</ol>\n<ul>\n<li>处理方式: 在事务开启之前要保证这条记录存在, 先进行一次搜索, 检查这条记录是否存在</li>\n<li>布隆过滤器的问题: 结果不一定准确</li>\n</ul>\n</li>\n<li>update加的是行锁(互斥锁, 不是共享锁)</li>\n<li>insert加表锁</li>\n<li>innodb引擎的锁机制依赖于什么<ul>\n<li>加锁机制是针对索引的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>user表增加sex字段, 并加索引, 是否会使用索引<ul>\n<li>不会. 使用索引的话涉及回表, 查出的结果集很大, 每条记录都需要回表, 回表意味着随机IO</li>\n<li>IO效率低的原因<ul>\n<li>寻道时间</li>\n<li>旋转时间</li>\n</ul>\n</li>\n<li>10%左右会弃用索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络<ul>\n<li>浏览器中输入网址, 经历了哪些网络过程<ul>\n<li>TCP为什么需要三次握手</li>\n<li>三次握手中能否携带应用层数据(比如HTTP报文)<ul>\n<li>TCP是双工协议</li>\n<li>前两次握手后, 单向通道已经建立, 在第三次握手时就可以携带HTTP报文</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTP2<ul>\n<li>HTTP2解决了HTTP中的哪些问题<ul>\n<li>减小体积, 但是丧失了可读性</li>\n<li>解决了慢启动问题</li>\n<li>多路复用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计模式<ul>\n<li>策略模式</li>\n</ul>\n</li>\n<li>实现斐波那契数列<ul>\n<li>递归带来函数栈的开销(N^2)</li>\n<li>记忆化搜索</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"B站二面\"><a href=\"#B站二面\" class=\"headerlink\" title=\"B站二面\"></a>B站二面</h3><ul>\n<li>挑有技术难点的业务项目</li>\n<li>介绍下Redis单线程模型是如何运行的, 优缺点</li>\n<li>Redis6.0多线程如何实现的?</li>\n<li>单线程模型对CPU利用率不高, 如何改造来解决这个问题?</li>\n<li>对于SQLselect * from table wher x&#x3D;1 and y&#x3D;2 order by z, 如何添加索引<ul>\n<li>画一下联合索引的节点是如何存储的</li>\n</ul>\n</li>\n<li>介绍一个做过的项目</li>\n<li>双端用户, 按用户和商户分库分表, 如果做数据聚合的检索, 如何设计</li>\n<li>kafka模型</li>\n<li>kafka出现部分节点不可用, 如何设计兜底方案</li>\n<li>线上接口超时了, 排查的思路?</li>\n</ul>\n<h2 id=\"币安\"><a href=\"#币安\" class=\"headerlink\" title=\"币安\"></a>币安</h2><h3 id=\"币安一面\"><a href=\"#币安一面\" class=\"headerlink\" title=\"币安一面\"></a>币安一面</h3><ul>\n<li>算法题: 求数组中的最大的unique数</li>\n<li>Go服务优雅退出</li>\n<li>MySQL什么时候会锁表<ul>\n<li>锁的类型<ul>\n<li>表级锁, 开销小, 加锁快, 不会出现死锁</li>\n<li>行级锁, 开销大, 加锁慢, 会出现死锁</li>\n<li>页面锁</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>介绍下ACID<ul>\n<li>原子性</li>\n<li>事务隔离</li>\n<li>持久性</li>\n<li>一致性</li>\n</ul>\n</li>\n<li>介绍Golang CAS</li>\n<li>MySQL隔离级别<ul>\n<li>未提交读</li>\n<li>不可重复读</li>\n<li>可重复读</li>\n<li>串行化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"币安二面\"><a href=\"#币安二面\" class=\"headerlink\" title=\"币安二面\"></a>币安二面</h3><ul>\n<li>自我介绍</li>\n<li>算法题<ul>\n<li>升序二维数组中第K大的元素</li>\n<li>getMinRout</li>\n</ul>\n</li>\n<li>Golang GC算法<ul>\n<li>三色标记的具体过程?</li>\n<li>写屏障?</li>\n</ul>\n</li>\n<li>Golang内存分配<ul>\n<li>TCMalloc 具体?</li>\n<li>内存分配的步骤?</li>\n<li>线性分配器&#x2F;空闲链表分配器?</li>\n<li>微对象&#x2F;小对象&#x2F;大对象   16B, 32KB</li>\n</ul>\n</li>\n<li>Golang GC&#x2F;GMP模型的演进?</li>\n<li>详细描述GMP模型</li>\n<li>Goroutine的调度时机<ul>\n<li>Go关键字</li>\n<li>runtime.GoSched</li>\n<li>GC</li>\n<li>系统调用</li>\n<li>内存同步访问(atomic&#x2F;mutex&#x2F;channel)</li>\n</ul>\n</li>\n<li>举例哪些操作系统操作会导致的Goroutine抢占</li>\n<li>系统调用包括哪些<ul>\n<li>进程控制</li>\n<li>文件管理</li>\n<li>设备管理</li>\n<li>信息维护</li>\n<li>通信</li>\n<li>保护</li>\n</ul>\n</li>\n<li>如何完成抢占(抢占的过程)?</li>\n<li>抢占是同步还是异步的?<ul>\n<li>1.14加入了异步抢占</li>\n<li>给协程发信号量(UNG的信号量)</li>\n<li>g0, g1?</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"币安三面\"><a href=\"#币安三面\" class=\"headerlink\" title=\"币安三面\"></a>币安三面</h3><ul>\n<li>自我介绍</li>\n<li>简介有技术难点的业务项目</li>\n<li>算法<ul>\n<li>getSubArray</li>\n</ul>\n</li>\n<li>DDD的核心</li>\n<li>分库分表的改造</li>\n<li>监控</li>\n<li>Redis高性能的原因</li>\n<li>LRU的实现原理</li>\n<li>遇到不熟悉的需求, 怎么处理</li>\n<li>方案上有分歧, 怎么处理</li>\n<li>可能延期的情况下, 怎么处理</li>\n</ul>\n<h2 id=\"得物\"><a href=\"#得物\" class=\"headerlink\" title=\"得物\"></a>得物</h2><h3 id=\"得物一面\"><a href=\"#得物一面\" class=\"headerlink\" title=\"得物一面\"></a>得物一面</h3><ul>\n<li>Golang和Java相比, 有什么缺点</li>\n<li>Java中好的组件如果用Golang迁移, 会有什么问题</li>\n<li>如何设计一个Golang DDD微服务框架</li>\n<li>如何看点框架化带来的性能损失的问题</li>\n<li>Golang&#x2F;Java&#x2F;Python中的垃圾回收机制</li>\n<li>MySQL B+树, Redis跳表</li>\n<li>解释下聚合索引</li>\n<li>Golang协程原理</li>\n<li>Golang中channel的锁</li>\n<li>PostgreSQL与MySQL对比</li>\n<li>多租户</li>\n</ul>\n<h3 id=\"得物二面\"><a href=\"#得物二面\" class=\"headerlink\" title=\"得物二面\"></a>得物二面</h3><ul>\n<li>订单锁的业务场景</li>\n<li>使用分布式锁有什么注意点</li>\n<li>如何保证cache和db的数据一致性</li>\n<li>如何避免缓存击穿<ul>\n<li>SingleFlight</li>\n<li>分布式锁, 不建议, 自研组件很难保证确实只有一个请求进行修改</li>\n<li>队列, 回写cache时对队列里的cache miss回写操作, 并检查cache是否已存在, 已存在则跳过</li>\n<li>lease</li>\n</ul>\n</li>\n<li>如何解决缓存穿透</li>\n<li>如何提升业务稳定性<ul>\n<li>事前</li>\n<li>事后</li>\n<li>其他?</li>\n</ul>\n</li>\n<li>限流有哪几种方式<ul>\n<li>计数器</li>\n<li>漏桶</li>\n<li>令牌桶算法</li>\n</ul>\n</li>\n<li>Context.WithValue的缺点</li>\n<li>Context.Timeout的实现<ul>\n<li>如何传递超时信号</li>\n</ul>\n</li>\n<li>map是否是并发安全的</li>\n<li>介绍CAS</li>\n<li>自旋锁和互斥锁的区别</li>\n<li>对已关闭的channel进行读写, 是否有问题<ul>\n<li>可以读, 返回false和或默认值0</li>\n<li>写入会直接panic: send on closed channel</li>\n</ul>\n</li>\n<li>Redis的有序集合是如何实现的<ul>\n<li>跳表 + 哈希</li>\n<li>压缩列表</li>\n</ul>\n</li>\n<li>聚簇索引的特点</li>\n<li>索引失效有哪些场景<ul>\n<li>避免or&#x2F;not in&#x2F; !&#x3D; &#x2F; &lt;&gt; 等操作</li>\n<li>使用了SQL内置函数</li>\n<li>where子句中order by是否使用了索引</li>\n</ul>\n</li>\n<li>解释下跳表和B+树</li>\n</ul>\n<h3 id=\"得物95线一面\"><a href=\"#得物95线一面\" class=\"headerlink\" title=\"得物95线一面\"></a>得物95线一面</h3><ul>\n<li>分库分表如何解决查询</li>\n<li>Prometheus</li>\n<li>Prometheus埋点数据是推还是拉</li>\n<li>Golang 高并发设计&#x2F;调度过程</li>\n<li>介绍MySQL事务</li>\n<li>MySQL如何修改隔离级别<ul>\n<li>set global.tx_isolation&#x3D;’READ-COMMITED’;</li>\n<li>或者修改my.cnf文件 transaction-isolation&#x3D;Read-Committed</li>\n</ul>\n</li>\n<li>Redis数据结构</li>\n<li>Redis持久化</li>\n<li>Redis中的原子操作有哪些</li>\n<li>grpc所使用的网络协议?有哪些<ul>\n<li>HTTP2是二进制协议, 所以丧失了可读性</li>\n<li>HTTP2多路复用, HTTP长连接复用</li>\n<li>grpc四种连接方式的区别? server stream和stream rpc的区别?</li>\n<li>grpc如何读取&#x2F;传输数据, 如何保证数据顺序</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TapTap\"><a href=\"#TapTap\" class=\"headerlink\" title=\"TapTap\"></a>TapTap</h2><h3 id=\"TapTap一面\"><a href=\"#TapTap一面\" class=\"headerlink\" title=\"TapTap一面\"></a>TapTap一面</h3><ul>\n<li>自我介绍</li>\n<li>Golang里做依赖注入 loc</li>\n<li>依赖注入的好处是什么</li>\n<li>Redis分布式锁</li>\n<li>缓存击穿是什么, 如何解决<ul>\n<li>SingleFlight</li>\n<li>分布式锁, 不建议, 自研组件很难保证确实只有一个请求进行修改</li>\n<li>队列, 回写cache时对队列里的cache miss回写操作, 并检查cache是否已存在, 已存在则跳过</li>\n<li>lease</li>\n</ul>\n</li>\n<li>Redis内存满了会怎么样<ul>\n<li>Redis配置最大使用内存(配置文件&#x2F;通过命令实时修改)</li>\n<li>LRU内存置换, 通过随机采样法淘汰数据, 每次随机出5个key, 从里面淘汰掉最近最少使用的key. Redis3.0中还会维护一个候选池, 将随机选取的key放入池中, 放满后将访问时间最大的进行移除</li>\n<li>如何解决<ul>\n<li>增加内存</li>\n<li>使用内存淘汰策略</li>\n<li>Redis集群</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Redis缓存淘汰机制<ul>\n<li>Redis会为每个key中额外增加内存空间用于存储每个key的使用时间, 大小是3字节</li>\n<li>Redis4.0中新增LFU算法(最近频繁被使用)<ul>\n<li>核心思想是根据key最近被访问的频率进行淘汰</li>\n</ul>\n</li>\n<li>六种淘汰策略<ul>\n<li>默认策略是当内存大小达到阈值, 所有申请内存的指令都会报错</li>\n<li>lru(allkeys&#x2F;volatile)</li>\n<li>random(allkeys&#x2F;volatile)</li>\n<li>ttl</li>\n</ul>\n</li>\n<li>如果Redis中的数据有明显的冷热特性, 推荐使用allkeys-lru. 如果所有数据访问频率大致一样, 可以用allkeys-random</li>\n</ul>\n</li>\n<li>Redis删除过期键策略<ul>\n<li>定时删除, 对内存最友好</li>\n<li>惰性删除</li>\n<li>定期删除</li>\n</ul>\n</li>\n<li>如何做LRU</li>\n<li>Golang GC机制<ul>\n<li>什么情况下会频繁GC<ul>\n<li>内存使用量持续增长</li>\n<li>小对象分配多</li>\n</ul>\n</li>\n<li>GC的触发机制<ul>\n<li>手动  runtime.gc()</li>\n<li>定期 默认2min触发一次gc</li>\n<li>阈值 内存扩大一倍时, 触发</li>\n</ul>\n</li>\n<li>如果优化来减少GC开销</li>\n<li>如何让对象创建在栈上而不是堆上<ul>\n<li>Go语言不同于C, 没有明确的堆栈区分, 具体分配到哪里由编译器自行决定. 一般情况下, 大对象或者存在引用(取地址)的对象会分配在堆上.</li>\n<li>反汇编查看内存分配情况<ul>\n<li>go tool compile -S main.go 分析汇编代码中是否调用了runtime.newobject</li>\n</ul>\n</li>\n<li>逃逸分析<ul>\n<li>go build -gcflags ‘-m -l’ main.go</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Golang内存对齐</li>\n<li>协程和线程的区别<ul>\n<li>为什么内存开销这么大</li>\n</ul>\n</li>\n<li>服务降级</li>\n<li>算法题<ul>\n<li>动规题<ul>\n<li>GetSteps</li>\n</ul>\n</li>\n<li>top k问题(堆排)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"小红书\"><a href=\"#小红书\" class=\"headerlink\" title=\"小红书\"></a>小红书</h2><h3 id=\"小红书面经\"><a href=\"#小红书面经\" class=\"headerlink\" title=\"小红书面经\"></a>小红书面经</h3><ul>\n<li>算法题<ul>\n<li>LRU</li>\n<li>删除链表的倒数第K个节点</li>\n</ul>\n</li>\n<li>Redis Cluster集群出现热点key或者大key怎么办<ul>\n<li>big key<ul>\n<li>危害<ul>\n<li>Redis阻塞, 操作单个big key耗时久, 后面请求会被阻塞</li>\n<li>cluster中胡造成内存空间不均匀</li>\n<li>过期时可能阻塞</li>\n</ul>\n</li>\n<li>排查: –bigkeys</li>\n<li>big key处理<ul>\n<li>删除bigkey, 异步删除需要Redis4.0支持</li>\n<li>拆分</li>\n<li>不用Redis, 改MongoDB</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>热key<ul>\n<li>如何发现热点<ul>\n<li>业务经验, 预估</li>\n<li>做数据统计, 在客户端进行收集</li>\n<li>redis自带的命令 hotkeys&#x2F;monitor</li>\n</ul>\n</li>\n<li>解决办法<ul>\n<li>利用二级缓存</li>\n<li>备份热key</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MySQL什么情况下会锁住整张表<ul>\n<li>insert时全表锁, 因为要生成主键字段&#x2F;索引等; update是行级锁</li>\n</ul>\n</li>\n<li>MySQL锁<ul>\n<li>表级锁</li>\n<li>行级锁</li>\n<li>页面锁</li>\n</ul>\n</li>\n<li>MySQL的行锁有几种<ul>\n<li>排它锁</li>\n<li>共享锁</li>\n</ul>\n</li>\n<li>MySQL索引, 为什么不适用hashmap</li>\n<li>覆盖索引原理, 使用uuid的问题</li>\n<li>缓存数据怎么和db保持同步</li>\n<li>缓存雪崩&#x2F;击穿&#x2F;穿透的解决办法</li>\n<li>限流怎么做<ul>\n<li>计数器</li>\n<li>令牌桶算法</li>\n<li>漏桶</li>\n</ul>\n</li>\n<li>消息幂等性怎么保证<ul>\n<li>利用数据库的唯一约束实现幂等</li>\n<li>去重表</li>\n<li>利用Redis原子性</li>\n<li>多版本控制(乐观锁)</li>\n</ul>\n</li>\n<li>乱序消息怎么解决<ul>\n<li>消息序列号</li>\n<li>借鉴TCP中ACK机制, 只有被确认的消息才可以被消费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小红书一面\"><a href=\"#小红书一面\" class=\"headerlink\" title=\"小红书一面\"></a>小红书一面</h3><ul>\n<li>自我介绍</li>\n<li>项目经历, 挑亮点项目<ul>\n<li>项目业务简介</li>\n<li>项目技术架构</li>\n<li>主要负责的内容</li>\n</ul>\n</li>\n<li>Golang内存分布<ul>\n<li>静态区</li>\n<li>栈区</li>\n<li>堆区</li>\n<li>常量区</li>\n<li>代码区</li>\n</ul>\n</li>\n<li>Java static关键字</li>\n<li>Java GC过程简介</li>\n<li>Redis中的数据结构<ul>\n<li>简单动态字符串</li>\n<li>整形数组</li>\n<li>压缩列表</li>\n<li>双向链表</li>\n<li>哈希表</li>\n<li>跳表</li>\n</ul>\n</li>\n<li>zset<ul>\n<li>跳表(主要作用是提高检索效率, 里面的key值是哈希值) + 哈希(去重)</li>\n<li>压缩列表(数据量小的时候)</li>\n</ul>\n</li>\n<li>Redis持久化方式<ul>\n<li>AOF</li>\n<li>RDB</li>\n<li>Redis4.0混合方式</li>\n</ul>\n</li>\n<li>Redis选举算法?<ul>\n<li>集群方案: cluster&#x2F;sentinel</li>\n</ul>\n</li>\n<li>对MVCC的理解</li>\n<li>MySQL锁机制<ul>\n<li>insert上表锁</li>\n<li>update上行锁</li>\n</ul>\n</li>\n<li>MySQL中三种log的区别<ul>\n<li>binlog<ul>\n<li>二进制数据</li>\n<li>MySQL server层实现的</li>\n<li>适用于主从同步和数据恢复</li>\n</ul>\n</li>\n<li>redo log<ul>\n<li>循环队列, 大小固定</li>\n<li>innodb引擎独有</li>\n<li>适用于crash safe崩溃恢复</li>\n</ul>\n</li>\n<li>undo log<ul>\n<li>保证原子性, 要么全成功要么全失败</li>\n<li>主要记录的是数据的逻辑变化</li>\n<li>MVCC多版本实现的关键(并发控制通过锁来实现)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>项目中重试&#x2F;降级&#x2F;熔断的实现</li>\n<li>限流的实现方案<ul>\n<li>计数器</li>\n<li>漏桶算法</li>\n<li>令牌桶算法</li>\n</ul>\n</li>\n<li>令牌桶算法的过程</li>\n<li>Redis为什么使用跳表而不使用B+树<ul>\n<li>内存利用率</li>\n</ul>\n</li>\n<li>算法题<ul>\n<li>动规题</li>\n<li>threeSum</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UCloud\"><a href=\"#UCloud\" class=\"headerlink\" title=\"UCloud\"></a>UCloud</h2><h3 id=\"UCloud一面\"><a href=\"#UCloud一面\" class=\"headerlink\" title=\"UCloud一面\"></a>UCloud一面</h3><ul>\n<li>自我介绍</li>\n<li>项目架构介绍</li>\n<li>介绍Golang GMP模型</li>\n<li>介绍Golang GC</li>\n</ul>\n<h3 id=\"UCloud二面\"><a href=\"#UCloud二面\" class=\"headerlink\" title=\"UCloud二面\"></a>UCloud二面</h3><ul>\n<li>自我介绍</li>\n<li>Golang和Java对比, 优劣势</li>\n<li>线程和Goroutine的区别</li>\n<li>早期Goroutine调度存在的问题<ul>\n<li>全局锁的性能问题</li>\n<li>早起是非抢占式调度</li>\n</ul>\n</li>\n<li>操作系统进程的通信方式, 各自的特点是什么<ul>\n<li>信号量(不适用于网络场景, 需要编程语言的支持)</li>\n<li>管道 (适合数据量大的场景)</li>\n<li>消息队列</li>\n<li>共享内存</li>\n</ul>\n</li>\n<li>亿级大表分库分表介绍</li>\n<li>如何防止SQL注入<ul>\n<li>预编译语句集</li>\n<li>使用正则表达式过滤传入的参数</li>\n<li>字符串过滤</li>\n<li>检查非法字符</li>\n</ul>\n</li>\n<li>GET和POST的区别?<ul>\n<li>网络传输上有区别吗</li>\n<li>GET请求参数长度的限制是哪一端做的</li>\n</ul>\n</li>\n<li>socket</li>\n<li>TCP和UDP的区别</li>\n<li>死锁是什么, 如何避免(宏观机制)<ul>\n<li>引起死锁的关键?</li>\n</ul>\n</li>\n<li>Golang中IOTA的原理?</li>\n<li>Java中String能否派生类</li>\n<li>Golang中接口的推断是静态的还是动态的?</li>\n<li>Golang中的error处理</li>\n<li>日志如何打<ul>\n<li>如何串联打日志(调用的链路都能统一打, 标识出来)</li>\n</ul>\n</li>\n<li>日志链路跟踪</li>\n<li>运维部署</li>\n</ul>\n<h3 id=\"UCloud三面\"><a href=\"#UCloud三面\" class=\"headerlink\" title=\"UCloud三面\"></a>UCloud三面</h3><ul>\n<li>自我介绍</li>\n<li>如何部署</li>\n<li>监控</li>\n<li>性能<ul>\n<li>压测</li>\n<li>可观测性</li>\n</ul>\n</li>\n<li>遇到的线上问题, 如何排查, 如何解决的</li>\n<li>提交读是否影响性能</li>\n<li>Linux如何查看端口是否被占用<ul>\n<li>lsof</li>\n<li>netstat</li>\n</ul>\n</li>\n<li>删文件发现空间未释放<ul>\n<li>惰性删除</li>\n<li>资源未释放</li>\n<li>软链</li>\n</ul>\n</li>\n<li>Golang如何限制使用的CPU数量</li>\n<li>Golang的core文件如何调试?</li>\n<li>算法题<ul>\n<li>日志文件分析</li>\n<li>负责均衡, 一致性哈希</li>\n<li>链表反转</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"触宝\"><a href=\"#触宝\" class=\"headerlink\" title=\"触宝\"></a>触宝</h2><h3 id=\"触宝一面\"><a href=\"#触宝一面\" class=\"headerlink\" title=\"触宝一面\"></a>触宝一面</h3><ul>\n<li>自我介绍</li>\n<li>手写Redis实现分布式锁</li>\n<li>介绍channel</li>\n<li>channel是否线程安全</li>\n<li>Golang的GC过程</li>\n<li>什么情况下GC压力会比较大, 对服务性能产生影响</li>\n<li>Golang常用的包管理方法, 项目结构如何设计</li>\n<li>ETCD是否用过</li>\n<li>ETCD和zookeeper的异同?</li>\n<li>Redis的数据结构有哪几种</li>\n<li>Redis事务的执行过程?</li>\n<li>Redis哈希的实现原理和时间复杂度</li>\n<li>Golang里有哪些锁<ul>\n<li>互斥锁</li>\n<li>读写锁</li>\n<li>自旋锁</li>\n</ul>\n</li>\n<li>map是否线程安全</li>\n<li>sync.map为什么是线程安全</li>\n<li>sync.map的数据结构</li>\n<li>Goroutine太多的问题</li>\n<li>如何限制Goroutine的数量</li>\n<li>操作系统<ul>\n<li>Linux中软中断机制?</li>\n<li>Linux在哪些情况下可能导致CPU物理核的使用不均匀?</li>\n<li>Linux单台机器可打开的文件句柄数量是多少, 如何查看, 如何调整?</li>\n<li>Linux压缩文件相关的操作</li>\n<li>文件如何移动</li>\n</ul>\n</li>\n<li>项目经历</li>\n<li>通用能力类的主观问题<ul>\n<li>遇到过什么线上问题&#x2F;trouble shouting</li>\n<li>多部门协作时困难的点</li>\n<li>发现一个功能点不符合预期, 链路比较复杂. 涉及多部门, 如何推进解决</li>\n<li>线上反馈的问题, 并不是你own的, 怎么处理 (相关的人又在休假)</li>\n<li>如何看待技术视角和产品视角, 怎么理解用户意识和客户意识</li>\n<li>项目管理如何做的</li>\n<li>在工作中犯过的错误</li>\n<li>如何保证线上稳定性</li>\n<li>如何实施压测</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"滴滴\"><a href=\"#滴滴\" class=\"headerlink\" title=\"滴滴\"></a>滴滴</h2><h2 id=\"滴滴一面\"><a href=\"#滴滴一面\" class=\"headerlink\" title=\"滴滴一面\"></a>滴滴一面</h2><ul>\n<li>自我介绍</li>\n<li>如何更好的转语言</li>\n<li>如何做Java&#x2F;Golang技术选型, 考虑哪些点</li>\n<li>项目经历</li>\n<li>MySQL删除时如何释放空间(空间的回收)</li>\n<li>微服务和DDD的区别</li>\n<li>为何决定使用DDD</li>\n<li>架构原则<ul>\n<li>单一职责</li>\n<li>依赖倒置</li>\n<li>接口隔离原则, 面向接口而不是依赖实现</li>\n<li>开闭原则</li>\n<li>里式替换</li>\n<li>迪米特法则, 最少知识原则</li>\n</ul>\n</li>\n<li>算法<ul>\n<li>isValid</li>\n<li>twoSum</li>\n<li>threeSum</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"滴滴二面\"><a href=\"#滴滴二面\" class=\"headerlink\" title=\"滴滴二面\"></a>滴滴二面</h3><ul>\n<li>介绍工作经历, 遇到的挑战</li>\n<li>缓存的应用场景, 如何更新</li>\n<li>算法题<ul>\n<li>[]string中第一列升序, 第二列按数字降序排列</li>\n<li>follow up, 假设数据量很大, 几百个G的待排数据, 内存只有几个G<ul>\n<li>map reduce</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最近看的技术书籍</li>\n</ul>\n<h2 id=\"Shopee\"><a href=\"#Shopee\" class=\"headerlink\" title=\"Shopee\"></a>Shopee</h2><h3 id=\"Shopee一面\"><a href=\"#Shopee一面\" class=\"headerlink\" title=\"Shopee一面\"></a>Shopee一面</h3><ul>\n<li>自我介绍</li>\n<li>算法题<ul>\n<li>rangeReverse List</li>\n<li>时间复杂度分析</li>\n</ul>\n</li>\n<li>如何实现哈希表</li>\n<li>进程和线程的区别</li>\n<li>进程间的通信方式</li>\n<li>多线程情况下, 计数器的实现会存在什么问题<ul>\n<li>如何保证线程安全</li>\n</ul>\n</li>\n<li>高并发的场景下, 加锁会带来性能开销, 如何解决?</li>\n<li>MySQL里的事务用来做什么</li>\n<li>MySQL里的索引用来做什么, 为什么要索引, 如何实现, 数据如何组织</li>\n<li>抖音首页推荐, 如何保证新的推荐是用户没有看过的</li>\n<li>布隆过滤器</li>\n</ul>\n<h3 id=\"Shopee-SG一面\"><a href=\"#Shopee-SG一面\" class=\"headerlink\" title=\"Shopee SG一面\"></a>Shopee SG一面</h3><ul>\n<li>自我介绍</li>\n<li>算法题<ul>\n<li>LRU实现</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Shopee-SG二面\"><a href=\"#Shopee-SG二面\" class=\"headerlink\" title=\"Shopee SG二面\"></a>Shopee SG二面</h3><ul>\n<li>自我介绍</li>\n<li>算法题<ul>\n<li>实现一个HashMap，需要解决哈希冲突</li>\n<li>存在的复杂度退化为O(N)的性能问题, 如何解决</li>\n</ul>\n</li>\n<li>Golang hashmap如何实现</li>\n<li>Golang Goroutine的实现</li>\n<li>Golang如何调度, 如何绑定</li>\n<li>MySQL的事务隔离级别</li>\n<li>innodb默认隔离级别, 如何实现的<ul>\n<li>DB follow up问题(略)</li>\n</ul>\n</li>\n<li>唯一ID的生成<ul>\n<li>UUID</li>\n<li>Redis原子操作</li>\n<li>雪花算法</li>\n</ul>\n</li>\n<li>业务架构设计</li>\n<li>项目架构介绍</li>\n<li>GC调优</li>\n</ul>\n<h3 id=\"Shopee-SG三面\"><a href=\"#Shopee-SG三面\" class=\"headerlink\" title=\"Shopee SG三面\"></a>Shopee SG三面</h3><ul>\n<li>算法题<ul>\n<li>找出两个数组中相同的元素</li>\n</ul>\n</li>\n<li>Golang示例代码闭包问题分析, 如何解决</li>\n<li>Golang开发过程中遇到的问题(坑)</li>\n<li>碰到的性能问题</li>\n<li>DB优化</li>\n</ul>\n<h2 id=\"米哈游\"><a href=\"#米哈游\" class=\"headerlink\" title=\"米哈游\"></a>米哈游</h2><h3 id=\"米哈游一面\"><a href=\"#米哈游一面\" class=\"headerlink\" title=\"米哈游一面\"></a>米哈游一面</h3><ul>\n<li>重点项目介绍, 遇到过的问题</li>\n<li>如何做容量预估</li>\n<li>context包的使用场景</li>\n<li>已关闭channel进行读写, nil的channel进行读写</li>\n<li>如何限制Goroutine数量</li>\n<li>并发读&#x2F;写是否有问题, 并发append元素是否有问题</li>\n<li>哪些场景会导致内存泄漏</li>\n<li>聚簇索引&#x2F;非聚簇索引, 非叶子节点存放的是什么</li>\n<li>索引覆盖</li>\n<li>悲观锁和乐观锁</li>\n<li>表锁&#x2F;行锁</li>\n<li>索引优化</li>\n<li>分库分表</li>\n<li>Redis锁的弊端</li>\n</ul>\n<h2 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h2><h3 id=\"字节一面\"><a href=\"#字节一面\" class=\"headerlink\" title=\"字节一面\"></a>字节一面</h3><ul>\n<li>自我介绍</li>\n<li>业务项目</li>\n<li>算法题<ul>\n<li>前序和中序构建二叉树</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"字节二面\"><a href=\"#字节二面\" class=\"headerlink\" title=\"字节二面\"></a>字节二面</h3><ul>\n<li>项目经历</li>\n<li>架构设计</li>\n<li>算法</li>\n</ul>\n<h3 id=\"字节三面\"><a href=\"#字节三面\" class=\"headerlink\" title=\"字节三面\"></a>字节三面</h3><ul>\n<li>项目介绍，现场画流程图</li>\n<li>算法<ul>\n<li>地铁寻路&#x2F;时间统计</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h2><h3 id=\"美团一面\"><a href=\"#美团一面\" class=\"headerlink\" title=\"美团一面\"></a>美团一面</h3><ul>\n<li>自我介绍</li>\n<li>离职原因</li>\n<li>k8s中有哪些网络模式?</li>\n<li>k8s CPU使用模式request和limit的区别?</li>\n<li>kafka的数据可靠性的保证?</li>\n<li>Redis布隆过滤器的使用场景</li>\n<li>Redis击破模型?</li>\n<li>Redis集群方案, 各自的优点?<ul>\n<li>cluster, 可扩展性</li>\n<li>sentinel, 高可用, master宕机, 自动将slave升级为master</li>\n</ul>\n</li>\n<li>Golang内存逃逸<ul>\n<li>Goroutine逃逸</li>\n<li>字符串截取, 共享内存</li>\n<li>子切片引用</li>\n<li>函数数组传参时</li>\n</ul>\n</li>\n<li>分库分表方案</li>\n<li>业务项目的技术难点</li>\n<li>API幂等设计</li>\n<li>gRPC的优点?</li>\n<li>JSON+gRPC的方案是否可行?</li>\n<li>Istio如何实现gRPC流量控制?</li>\n<li>HTTP2的特点?</li>\n<li>thrift和grpc的对比?</li>\n<li>xorm和gorm的对比?</li>\n<li>设计一个ORM, 有哪些重要的模块</li>\n<li>DB中的一张表在gorm中是什么样的数据结构</li>\n<li>MVC和MVP的区别? </li>\n<li>gin middleware<ul>\n<li>鉴权如何实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"腾讯\"><a href=\"#腾讯\" class=\"headerlink\" title=\"腾讯\"></a>腾讯</h2><h3 id=\"腾讯电商一面\"><a href=\"#腾讯电商一面\" class=\"headerlink\" title=\"腾讯电商一面\"></a>腾讯电商一面</h3><ul>\n<li>自我介绍</li>\n<li>项目经历, 业务流程&#x2F;架构简介</li>\n<li>BFF是什么, 和网关的区别是什么</li>\n<li>Redis哈希是如何实现的</li>\n<li>一般来说哈希map有几种实现方式</li>\n<li>Redis什么情况下触发渐进式哈希</li>\n<li>Redis是否使用集群, 集群如何保证高可用</li>\n<li>Redis集群的选举算法?</li>\n<li>Redis扩容时如何保证数据的一致性?</li>\n<li>Redis集群数据是如何分布的? 如何决定一个key存放在哪个节点上<ul>\n<li>sharding方式有哪些</li>\n</ul>\n</li>\n<li>Redis大key&#x2F;热key的解决办法</li>\n<li>MySQL事务的隔离级别<ul>\n<li>未提交读</li>\n<li>不可重复读</li>\n<li>可重复读</li>\n<li>串行化</li>\n</ul>\n</li>\n<li>可重复和不可重复的区别</li>\n<li>幻读?</li>\n<li>MySQL如何实现可重复读(MVCC)</li>\n<li>算法题<ul>\n<li>三数最接近的target</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>Golang内存泄漏<ul>\n<li>Goroutine泄漏<ul>\n<li>Goroutine栈本身锁占用空间</li>\n<li>Goroutine堆的占用空间</li>\n<li>如何判断: 检测Goroutine数量, 观察是否持续增长</li>\n</ul>\n</li>\n<li>排查方式<ul>\n<li>pprof<ul>\n<li>top</li>\n<li>list</li>\n<li>traces</li>\n</ul>\n</li>\n<li>监控工具, 观察内存使用量的走势</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Prometheus metrics类型<ul>\n<li>Counter计数器</li>\n<li>Gauge仪表盘</li>\n<li>histogram和summary 分布数据分布情况</li>\n</ul>\n</li>\n</ul>\n","categories":[],"tags":["面经"]},{"title":"Golang Context的好坏与使用建议","url":"https://blog.ranchocooper.com/2021/08/14/golang-context-tips/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p><code>context</code>的设计在Golang中算是一个比较有争议的话题。<code>context</code>不是银弹，它解决了一些问题的同时，也有不少让人诟病的缺点。本文主要探讨一下<code>context</code>的优缺点以及一些使用建议。</p>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>由于主观上我也不是很喜欢context的设计，所以我们就从缺点先开始吧。</p>\n<h2 id=\"到处都是context\"><a href=\"#到处都是context\" class=\"headerlink\" title=\"到处都是context\"></a>到处都是context</h2><p>根据<code>context</code>使用的官方建议，<code>context</code>应当出现在函数的第一个参数上。这就直接导致了代码中到处都是<code>context</code>。作为函数的调用者，即使你不打算使用<code>context</code>的功能，你也必须传一个占位符——<code>context.Background()</code>或<code>context.TODO()</code>。这无疑是一种<code>code smell</code>，特别是对于有代码洁癖程序员来说，传递这么多无意义的参数是简直是令人无法接受的。</p>\n<h2 id=\"context-Value——没有约束的自由是危险的\"><a href=\"#context-Value——没有约束的自由是危险的\" class=\"headerlink\" title=\"context.Value——没有约束的自由是危险的\"></a>context.Value——没有约束的自由是危险的</h2><p><code>context.Value</code>几乎就是一个 <code>map[interface&#123;&#125;]interface&#123;&#125;</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Value(key <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可读性很差\"><a href=\"#可读性很差\" class=\"headerlink\" title=\"可读性很差\"></a>可读性很差</h2><p>可读性差也是自由带来的代价，在学习阅读Go代码的时候，看到<code>context</code>是令人头疼的一件事。如果文档注释的不够清晰，你几乎无法得知<code>context.Value</code>里究竟包含什么内容，更不谈如何正确的使用这些内容了。</p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><h2 id=\"统一了cancelation的实现方法\"><a href=\"#统一了cancelation的实现方法\" class=\"headerlink\" title=\"统一了cancelation的实现方法\"></a>统一了cancelation的实现方法</h2><p>许多文章都说<code>context</code>解决了goroutine的cancelation问题，但实际上，我觉得cancelation的实现本身不算是一个问题，利用关闭<code>channel</code>的广播特性，实现cancelation是一件比较简单的事情，举个栗子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Cancel触发一个取消</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Cancel</span><span class=\"params\">(c <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-c: <span class=\"comment\">//已经取消过了, 防止重复close</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DoSomething做一些耗时操作，可以被cancel取消。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DoSomething</span><span class=\"params\">(cancel <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, arg Arg)</span></span>  &#123;</span><br><span class=\"line\">    rs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Result)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">        rs &lt;- xxx  <span class=\"comment\">//返回处理结果</span></span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-cancel:</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;取消了&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> result := &lt;-rs:</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;处理完成&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者你也可以把用于取消的channel放到结构体里：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Task <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Arg Arg</span><br><span class=\"line\">    cancel <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">//取消channel</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewTask 根据参数新建一个Task</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTask</span><span class=\"params\">(arg Arg)</span></span> *Task&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Task&#123;</span><br><span class=\"line\">        Arg:arg ,</span><br><span class=\"line\">        cancel:<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cancel触发一个取消</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Task)</span></span> Cancel() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-t.c: <span class=\"comment\">//已经取消过了, 防止重复close</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(t.c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DoSomething做一些耗时操作，可以被cancel取消。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Task)</span></span> DoSomething() &#123;</span><br><span class=\"line\">    rs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Result)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">        rs &lt;- xxx</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-t.cancel:</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;取消了&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> result := &lt;-rs:</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;处理完成&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// t := NewTask(arg)</span></span><br><span class=\"line\"><span class=\"comment\">// t.DoSomething()</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，对cancelation的实现也是多种多样的。一千个程序员由可能写出一千种实现方式。不过幸亏有<code>context</code>统一了cancelation的实现，不然怕是每引用一个库，你都得额外学习一下它的cancelation机制了。我认为这是context最大的优点，也是最大的功劳。gopher们只要看到函数中有<code>context</code>，就知道如何取消该函数的执行。如果想要实现cancelation，就会优先考虑<code>context</code>。</p>\n<h2 id=\"提供了一种不那么优雅，但是有效的传值方式\"><a href=\"#提供了一种不那么优雅，但是有效的传值方式\" class=\"headerlink\" title=\"提供了一种不那么优雅，但是有效的传值方式\"></a>提供了一种不那么优雅，但是有效的传值方式</h2><p><code>context.Value</code>是一把双刃剑，上文中提到了它的缺点，但只要运用得当，缺点也可以变优点。<code>map[interface&#123;&#125;]interface&#123;&#125;</code>的属性决定了它几乎能存任何内容，如果某方法需要cancelation的同时，还需要能接收调用方传递的任何数据，那<code>context.Value</code>还是十分有效的方式。如何“运用得当”请参考下面的使用建议。</p>\n<h1 id=\"context使用建议\"><a href=\"#context使用建议\" class=\"headerlink\" title=\"context使用建议\"></a>context使用建议</h1><h2 id=\"需要cancelation的时候才考虑context\"><a href=\"#需要cancelation的时候才考虑context\" class=\"headerlink\" title=\"需要cancelation的时候才考虑context\"></a>需要cancelation的时候才考虑context</h2><p><code>context</code>主要就是两大功能，cancelation和<code>context.Value</code>。如果你仅仅是需要在goroutine之间传值，请不要使用<code>context</code>。因为在Go的世界里，<code>context</code>一般默认都是能取消的，一个不能取消的<code>context</code>很容易被调用方误解。</p>\n<pre><code>一个不能取消的context是没有灵魂的。\n</code></pre>\n<h2 id=\"context-Value能不用就不用\"><a href=\"#context-Value能不用就不用\" class=\"headerlink\" title=\"context.Value能不用就不用\"></a>context.Value能不用就不用</h2><p><code>context.Value</code>内容的存取应当由库的使用者来负责。如果是库内部自身的数据流转，那么请不要使用<code>context.Value</code>，因为这部分数据通常是固定的，可控的。假设某系统中的鉴权模块，需要一个字符串<code>token</code>来鉴权，对比下面两种实现方式，显然是显示将<code>token</code>作为参数传递更清晰。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用context</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsAdminUser</span><span class=\"params\">(ctx context.Context)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    x := token.GetToken(ctx)</span><br><span class=\"line\">    userObject := auth.AuthenticateToken(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userObject.IsAdmin() || userObject.IsRoot()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不用context</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsAdminUser</span><span class=\"params\">(token <span class=\"type\">string</span>, authService AuthService)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    userObject := authService.AuthenticateToken(token)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userObject.IsAdmin() || userObject.IsRoot()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，请忘了<code>request-scoped</code>吧，把<code>context.Value</code>想象成是<code>user-scoped</code>——让用户，也就是库的调用者来决定在<code>context.Value</code>里面放什么。</p>\n<h2 id=\"使用NewContext和FromContext对来存取context\"><a href=\"#使用NewContext和FromContext对来存取context\" class=\"headerlink\" title=\"使用NewContext和FromContext对来存取context\"></a>使用NewContext和FromContext对来存取context</h2><p>不要直接使用<code>context.WithValue()</code>和<code>context.Value(&quot;key&quot;)</code>来存取数据，将<code>context.Value</code>的存取做一层封装能有效降低代码冗余，增强代码可读性同时最大限度的防止一些粗心的错误。</p>\n<h2 id=\"如果使用context-Value，请注释清楚\"><a href=\"#如果使用context-Value，请注释清楚\" class=\"headerlink\" title=\"如果使用context.Value，请注释清楚\"></a>如果使用context.Value，请注释清楚</h2><p>上面提到，<code>context.Value</code>可读性是十分差的，所以我们不得不用文档和注释的方式来进行弥补。至少列举所有可能的<code>context.Value</code>以及它们的get&#x2F;set方法（<code>NewContext(),FromContext()</code>），尽可能的列举函数入参与<code>context.Value</code>之间的关系，给阅读或维护你代码的人多一份关爱。</p>\n<h2 id=\"封装以减少context-TODO-或context-Background\"><a href=\"#封装以减少context-TODO-或context-Background\" class=\"headerlink\" title=\"封装以减少context.TODO()或context.Background()\"></a>封装以减少context.TODO()或context.Background()</h2><p>对于那些提供了<code>context</code>的方法，但作为调用方我们并不使用的，还是不得不传<code>context.TODO()</code>或<code>context.Background()</code>。如果你不能忍受大量无用的<code>context</code>在代码中扩散，可以对这些方法做一层封装：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有如下查询方法，但我们几乎不使用其提供的context</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">QueryContext</span><span class=\"params\">(ctx context.Context, query <span class=\"type\">string</span>, args []NamedValue)</span></span> (Rows, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 封装一下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Query</span><span class=\"params\">(query <span class=\"type\">string</span>, args []NamedValue)</span></span> (Rows, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> QueryContext(context.Background(), query, args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["编程语言","Golang"]},{"title":"算法进阶(07) - DFS、BFS","url":"https://blog.ranchocooper.com/2021/07/10/advanced-algorith-07/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"DFS-VS-BFS\"><a href=\"#DFS-VS-BFS\" class=\"headerlink\" title=\"DFS VS BFS\"></a>DFS VS BFS</h1><p>DFS更适合搜索树形状态空间</p>\n<ul>\n<li>递归本身就会产生树的结构</li>\n<li>可以用一个全局变量维护状态较为复杂的信息(子集&#x2F;排列)</li>\n<li>不需要队列, 节省空间</li>\n</ul>\n<p>BFS适合求<code>最小代价</code>、<code>最少步数</code>之类的题目</p>\n<ul>\n<li>BFS是按层次序搜索, 任意时刻队列中至多只有两层</li>\n</ul>\n<p>在状态空间为一般的<code>图</code>时(需要判重), DFS&#x2F;BFS均可</p>\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><h2 id=\"电话号码的字母组合\"><a href=\"#电话号码的字母组合\" class=\"headerlink\" title=\"电话号码的字母组合\"></a>电话号码的字母组合</h2><p><a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\">LeetCode</a></p>\n<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(digits <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> digits == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    phone := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>)</span><br><span class=\"line\">    phone[<span class=\"string\">&quot;2&quot;</span>] = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;3&quot;</span>] = <span class=\"string\">&quot;def&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;4&quot;</span>] = <span class=\"string\">&quot;ghi&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;5&quot;</span>] = <span class=\"string\">&quot;jkl&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;6&quot;</span>] = <span class=\"string\">&quot;mno&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;7&quot;</span>] = <span class=\"string\">&quot;pqrs&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;8&quot;</span>] = <span class=\"string\">&quot;tuv&quot;</span></span><br><span class=\"line\">    phone[<span class=\"string\">&quot;9&quot;</span>] = <span class=\"string\">&quot;wxyz&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">string</span>, <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(digits <span class=\"type\">string</span>, index <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index == <span class=\"built_in\">len</span>(digits) &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans, str)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, digit := <span class=\"keyword\">range</span> phone[<span class=\"type\">string</span>(digits[index])] &#123;</span><br><span class=\"line\">            str = fmt.Sprintf(<span class=\"string\">&quot;%s%s&quot;</span>, str, <span class=\"type\">string</span>(digit))</span><br><span class=\"line\">            dfs(digits, index + <span class=\"number\">1</span>)</span><br><span class=\"line\">            str = str[:<span class=\"built_in\">len</span>(str)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(digits, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"N-皇后\"><a href=\"#N-皇后\" class=\"headerlink\" title=\"N 皇后\"></a>N 皇后</h2><p><a href=\"https://leetcode-cn.com/problems/n-queens/\">LeetCode</a></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">solveNQueens</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    results := <span class=\"built_in\">make</span>([][]<span class=\"type\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    an := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    used := <span class=\"built_in\">make</span>([]<span class=\"type\">bool</span>, n)</span><br><span class=\"line\">    usedIplusJ := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    usedIminusJ := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> find <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    find = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(row <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> row == n &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans, <span class=\"built_in\">append</span>([]<span class=\"type\">int</span>(<span class=\"literal\">nil</span>), an...))   <span class=\"comment\">// 注意这里要复制切片</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> col := <span class=\"number\">0</span>; col &lt; n; col++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> !used[col] &amp;&amp; !usedIplusJ[row + col] &amp;&amp; !usedIminusJ[row - col] &#123;</span><br><span class=\"line\">                used[col] = <span class=\"literal\">true</span></span><br><span class=\"line\">                usedIplusJ[row + col] = <span class=\"literal\">true</span></span><br><span class=\"line\">                usedIminusJ[row - col] = <span class=\"literal\">true</span></span><br><span class=\"line\">                an = <span class=\"built_in\">append</span>(an, col)</span><br><span class=\"line\">                find(row+<span class=\"number\">1</span>)</span><br><span class=\"line\">                an = an[:<span class=\"built_in\">len</span>(an) - <span class=\"number\">1</span>]</span><br><span class=\"line\">                usedIminusJ[row - col] = <span class=\"literal\">false</span></span><br><span class=\"line\">                usedIplusJ[row + col] = <span class=\"literal\">false</span></span><br><span class=\"line\">                used[col] = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    find(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转换成 &quot;..Q.&quot;的形式</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, each := <span class=\"keyword\">range</span> ans &#123;</span><br><span class=\"line\">        result := <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> row := <span class=\"number\">0</span>; row &lt; n; row++ &#123;</span><br><span class=\"line\">            s := strings.Repeat(<span class=\"string\">&quot;.&quot;</span>, n)</span><br><span class=\"line\">            b := []<span class=\"type\">byte</span>(s)</span><br><span class=\"line\">            b[each[row]] = <span class=\"string\">&#x27;Q&#x27;</span></span><br><span class=\"line\">            s = <span class=\"type\">string</span>(b)</span><br><span class=\"line\">            result = <span class=\"built_in\">append</span>(result, s)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results = <span class=\"built_in\">append</span>(results, result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"岛屿数量\"><a href=\"#岛屿数量\" class=\"headerlink\" title=\"岛屿数量\"></a>岛屿数量</h2><p><a href=\"https://leetcode-cn.com/problems/number-of-islands/\">LeetCode</a></p>\n<h3 id=\"解法一-DFS\"><a href=\"#解法一-DFS\" class=\"headerlink\" title=\"解法一: DFS\"></a>解法一: DFS</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numIslands</span><span class=\"params\">(grid [][]<span class=\"type\">byte</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"number\">0</span></span><br><span class=\"line\">    m := <span class=\"built_in\">len</span>(grid)</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化visited二维数组</span></span><br><span class=\"line\">    visited := <span class=\"built_in\">make</span>([][]<span class=\"type\">bool</span>, m)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; m; i++ &#123;</span><br><span class=\"line\">        visited[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">bool</span>, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方向数组</span></span><br><span class=\"line\">    dx := []<span class=\"type\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    dy := []<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([][]<span class=\"type\">byte</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(grid [][]<span class=\"type\">byte</span>, x, y <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 标记visited状态</span></span><br><span class=\"line\">        visited[x][y] = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 向四个方向dfs</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">            nx := x + dx[i]</span><br><span class=\"line\">            ny := y + dy[i]</span><br><span class=\"line\">            <span class=\"comment\">// 越界情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= m || ny &gt;= n &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"type\">string</span>(grid[nx][ny]) == <span class=\"string\">&quot;1&quot;</span> &amp;&amp; !visited[nx][ny] &#123;</span><br><span class=\"line\">                dfs(grid, nx, ny)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; m; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; n; j++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"type\">string</span>(grid[i][j]) == <span class=\"string\">&quot;1&quot;</span> &amp;&amp; !visited[i][j] &#123;</span><br><span class=\"line\">                dfs(grid, i, j)</span><br><span class=\"line\">                ans++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法二-BFS\"><a href=\"#解法二-BFS\" class=\"headerlink\" title=\"解法二: BFS\"></a>解法二: BFS</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numIslands</span><span class=\"params\">(grid [][]<span class=\"type\">byte</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"number\">0</span></span><br><span class=\"line\">    m := <span class=\"built_in\">len</span>(grid)</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 方向数组</span></span><br><span class=\"line\">    dx := []<span class=\"type\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    dy := []<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited := <span class=\"built_in\">make</span>([][]<span class=\"type\">bool</span>, m)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; m; i++ &#123;</span><br><span class=\"line\">        visited[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">bool</span>, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> bfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([][]<span class=\"type\">byte</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    bfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(grid [][]<span class=\"type\">byte</span>, x, y <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        visited[x][y] = <span class=\"literal\">true</span></span><br><span class=\"line\">        queue := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        queue = <span class=\"built_in\">append</span>(queue, []<span class=\"type\">int</span>&#123;x, y&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(queue) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            current := queue[<span class=\"number\">0</span>]</span><br><span class=\"line\">            queue = queue[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">                nx := current[<span class=\"number\">0</span>] + dx[i]</span><br><span class=\"line\">                ny := current[<span class=\"number\">1</span>] + dy[i]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 越界情况</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= m || ny &gt;= n &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"type\">string</span>(grid[nx][ny]) == <span class=\"string\">&quot;1&quot;</span> &amp;&amp; !visited[nx][ny] &#123;</span><br><span class=\"line\">                    queue = <span class=\"built_in\">append</span>(queue, []<span class=\"type\">int</span>&#123;nx, ny&#125;)</span><br><span class=\"line\">                    visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; m; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; n; j++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"type\">string</span>(grid[i][j]) == <span class=\"string\">&quot;1&quot;</span> &amp;&amp; !visited[i][j] &#123;</span><br><span class=\"line\">                bfs(grid, i, j)</span><br><span class=\"line\">                ans++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最小基因变化\"><a href=\"#最小基因变化\" class=\"headerlink\" title=\"最小基因变化\"></a>最小基因变化</h2><p><a href=\"https://leetcode-cn.com/problems/minimum-genetic-mutation/\">LeetCode</a></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minMutation</span><span class=\"params\">(start <span class=\"type\">string</span>, end <span class=\"type\">string</span>, bank []<span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录变化步数</span></span><br><span class=\"line\">    depth := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    genetic := []<span class=\"type\">byte</span>&#123;<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>, <span class=\"string\">&#x27;T&#x27;</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将bank转换为map, 方便比对</span></span><br><span class=\"line\">    bankSet := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> bank &#123;</span><br><span class=\"line\">        bankSet[s] = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue := <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    queue = <span class=\"built_in\">append</span>(queue, start)</span><br><span class=\"line\">    depth[start] = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(queue) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        current := queue[<span class=\"number\">0</span>]</span><br><span class=\"line\">        queue = queue[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(start); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(genetic); j++ &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> current[i] == genetic[j] &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                byteNext := []<span class=\"type\">byte</span>(current)</span><br><span class=\"line\">                byteNext[i] = genetic[j]</span><br><span class=\"line\">                next := <span class=\"type\">string</span>(byteNext)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> _, ok := bankSet[next]; !ok &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// next不在基因库中</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> _, ok := depth[next]; !ok &#123;</span><br><span class=\"line\">                    depth[next] = depth[current] + <span class=\"number\">1</span></span><br><span class=\"line\">                    queue = <span class=\"built_in\">append</span>(queue, next)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> next == end &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> depth[next]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["算法"]},{"title":"算法进阶(06) - 树、图","url":"https://blog.ranchocooper.com/2021/07/06/advanced-algorith-06/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"二叉树的中序遍历\"><a href=\"#二叉树的中序遍历\" class=\"headerlink\" title=\"二叉树的中序遍历\"></a>二叉树的中序遍历</h2><p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">LeetCode</a></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    inorder(root, &amp;ans)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">inorder</span><span class=\"params\">(root *TreeNode, ans *[]<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inorder(root.Left, ans)</span><br><span class=\"line\">    *ans = <span class=\"built_in\">append</span>(*ans, root.Val)</span><br><span class=\"line\">    inorder(root.Right, ans)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"N-叉树的前序遍历\"><a href=\"#N-叉树的前序遍历\" class=\"headerlink\" title=\"N 叉树的前序遍历\"></a>N 叉树的前序遍历</h2><h3 id=\"解法一-递归\"><a href=\"#解法一-递归\" class=\"headerlink\" title=\"解法一 递归\"></a>解法一 递归</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type Node struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Children []*Node</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preorder</span><span class=\"params\">(root *Node)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    pre(root, &amp;ans)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pre</span><span class=\"params\">(root *Node, ans *[]<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *ans = <span class=\"built_in\">append</span>(*ans, root.Val)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> root.Children &#123;</span><br><span class=\"line\">        pre(child, ans)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法二-迭代\"><a href=\"#解法二-迭代\" class=\"headerlink\" title=\"解法二 迭代\"></a>解法二 迭代</h3><p>维护一个栈, 先将root入栈, 然后将其children逆序压入栈中, 然后不断出栈处理, 直到栈为空</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type Node struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Children []*Node</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preorder</span><span class=\"params\">(root *Node)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*Node, <span class=\"number\">0</span>)</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack, root)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ; <span class=\"built_in\">len</span>(stack) !=  <span class=\"number\">0</span>; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pop</span></span><br><span class=\"line\">        current := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans, current.Val)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(current.Children); i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, current.Children[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"N-叉树的层序遍历\"><a href=\"#N-叉树的层序遍历\" class=\"headerlink\" title=\"N 叉树的层序遍历\"></a>N 叉树的层序遍历</h2><p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\">LeetCode</a></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>维护一个队列, 先将root入队, 不断取出队首元素(一层的全部Node列表)), 遍历其中的每个node, 将node的值和Children分别存储到切片中, 完成遍历后再将所有的node值切片插入到<code>ans</code>中<br>, 并将所有的<code>Children</code>入队, 直到队列为空</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type Node struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Children []*Node</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *Node)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    queue := <span class=\"built_in\">make</span>([][]*Node, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    queue = <span class=\"built_in\">append</span>(queue, []*Node&#123;root&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(queue) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// lpop</span></span><br><span class=\"line\">        nodes := queue[<span class=\"number\">0</span>]</span><br><span class=\"line\">        queue = queue[<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">        levels := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        levelChildren := <span class=\"built_in\">make</span>([]*Node, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, node := <span class=\"keyword\">range</span> nodes &#123;</span><br><span class=\"line\">            levels = <span class=\"built_in\">append</span>(levels, node.Val)</span><br><span class=\"line\">            levelChildren = <span class=\"built_in\">append</span>(levelChildren, node.Children...)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(levels) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            queue = <span class=\"built_in\">append</span>(queue, levelChildren)</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans, levels)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树的序列化与反序列化\"><a href=\"#二叉树的序列化与反序列化\" class=\"headerlink\" title=\"二叉树的序列化与反序列化\"></a>二叉树的序列化与反序列化</h2><p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">LeetCode</a></p>\n<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从前序与中序遍历序列构造二叉树\"><a href=\"#从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"从前序与中序遍历序列构造二叉树\"></a>从前序与中序遍历序列构造二叉树</h2><p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">LeetCode</a></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder []<span class=\"type\">int</span>, inorder []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(preorder, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(preorder)<span class=\"number\">-1</span>, inorder, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(inorder)<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span><span class=\"params\">(preorder []<span class=\"type\">int</span>, l1, r1 <span class=\"type\">int</span>, inorder []<span class=\"type\">int</span>, l2, r2 <span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l1 &gt; r1 &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root := &amp;TreeNode&#123;</span><br><span class=\"line\">        Val: preorder[l1], </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mid := l2</span><br><span class=\"line\">    <span class=\"keyword\">for</span> inorder[mid] != root.Val &#123;</span><br><span class=\"line\">        mid++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root.Left = build(preorder, l1+<span class=\"number\">1</span>, l1+mid-l2, inorder, l2, mid+<span class=\"number\">1</span>)</span><br><span class=\"line\">    root.Right = build(preorder, l1+mid-l2+<span class=\"number\">1</span>, r1, inorder, mid+<span class=\"number\">1</span>, r2)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树的最近公共祖先\"><a href=\"#二叉树的最近公共祖先\" class=\"headerlink\" title=\"二叉树的最近公共祖先\"></a>二叉树的最近公共祖先</h2><p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">LeetCode</a></p>\n<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>首先维护一个map, 保存从每个节点到其父节点的映射(题目中每个节点的value不相同). 然后从q向上标记祖先节点, 放入redNotes中, 再对p求祖先, 当遇到第一个在redNotes中的祖先节点时, 即为最近的公共祖先</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> || root == p || root == q &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fathers := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*TreeNode, <span class=\"number\">0</span>)</span><br><span class=\"line\">    redNodes := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> calcFather <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span></span><br><span class=\"line\">    calcFather = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fathers[root.Left.Val] = root</span><br><span class=\"line\">            calcFather(root.Left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fathers[root.Right.Val] = root</span><br><span class=\"line\">            calcFather(root.Right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    calcFather(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp := p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> tmp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        redNodes[tmp.Val] = <span class=\"literal\">true</span></span><br><span class=\"line\">        tmp = fathers[tmp.Val]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = q</span><br><span class=\"line\">    <span class=\"keyword\">for</span> tmp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> redNodes[tmp.Val] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tmp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp = fathers[tmp.Val]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"课程表\"><a href=\"#课程表\" class=\"headerlink\" title=\"课程表\"></a>课程表</h2><p><a href=\"https://leetcode-cn.com/problems/course-schedule/\">LeetCode</a></p>\n<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>\n<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>\n<pre><code>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。\n</code></pre>\n<p>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canFinish</span><span class=\"params\">(numCourses <span class=\"type\">int</span>, prerequisites [][]<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 出边数组</span></span><br><span class=\"line\">    edges := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, numCourses)</span><br><span class=\"line\">    <span class=\"comment\">// 记录每个点的入度</span></span><br><span class=\"line\">    inDegree := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, numCourses)</span><br><span class=\"line\">    <span class=\"comment\">// 可学习的课程数量</span></span><br><span class=\"line\">    learned := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加边(x到y)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> addEdge <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    addEdge = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        edges[x] = <span class=\"built_in\">append</span>(edges[x], y)</span><br><span class=\"line\">        inDegree[y]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拓扑排序</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> topSort <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    topSort = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        queue := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将所有入度为0的点入队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> inDegree[i] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                queue = <span class=\"built_in\">append</span>(queue, i)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(queue) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// pop</span></span><br><span class=\"line\">            x := queue[<span class=\"number\">0</span>]</span><br><span class=\"line\">            queue = queue[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            learned++</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// x已学, 令其每个出边点的度数-1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> _, y := <span class=\"keyword\">range</span> edges[x] &#123;</span><br><span class=\"line\">                inDegree[y]--</span><br><span class=\"line\">                <span class=\"keyword\">if</span> inDegree[y] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    queue = <span class=\"built_in\">append</span>(queue, y)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, pre := <span class=\"keyword\">range</span> prerequisites &#123;</span><br><span class=\"line\">        addEdge(pre[<span class=\"number\">1</span>], pre[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    topSort()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> learned == numCourses</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"冗余连接\"><a href=\"#冗余连接\" class=\"headerlink\" title=\"冗余连接\"></a>冗余连接</h2><p><a href=\"https://leetcode-cn.com/problems/redundant-connection/description/\">LeetCode</a></p>\n<p>在本问题中, 树指的是一个连通且无环的无向图。</p>\n<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>\n<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>\n<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findRedundantConnection</span><span class=\"params\">(input [][]<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 出现最大的点数就是n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, edge := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">        u, v := edge[<span class=\"number\">0</span>], edge[<span class=\"number\">1</span>]</span><br><span class=\"line\">        n = max(u, n)</span><br><span class=\"line\">        n = max(v, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hasCycle <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 出边数组</span></span><br><span class=\"line\">    edges := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    visited := <span class=\"built_in\">make</span>([]<span class=\"type\">bool</span>, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, father <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, father <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        visited[x] = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, y := <span class=\"keyword\">range</span> edges[x] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> y == father &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> visited[y] &#123;</span><br><span class=\"line\">                hasCycle = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dfs(y, x)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加边</span></span><br><span class=\"line\">    addEdge := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        edges[x] = <span class=\"built_in\">append</span>(edges[x], y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化出边数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= n; i++ &#123;</span><br><span class=\"line\">        edges = <span class=\"built_in\">append</span>(edges, <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, edge := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">        u, v := edge[<span class=\"number\">0</span>], edge[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">// 无向图看作双向边的有向图</span></span><br><span class=\"line\">        addEdge(u, v);</span><br><span class=\"line\">        addEdge(v, u);</span><br><span class=\"line\">        <span class=\"comment\">// 每加一条边，看图中是否多了环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= n; i++ &#123;</span><br><span class=\"line\">            visited[i] = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(u, <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hasCycle &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> edge</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a &gt;= b &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":[],"tags":["算法"]},{"title":"算法进阶(05) - 递归、分治","url":"https://blog.ranchocooper.com/2021/07/03/advanced-algorithm-05/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><h2 id=\"递归的时间复杂度\"><a href=\"#递归的时间复杂度\" class=\"headerlink\" title=\"递归的时间复杂度\"></a>递归的时间复杂度</h2><ul>\n<li>指数型: k^n (子集, 大体积背包问题)</li>\n<li>排列型: n! (全排列, 旅行商, N皇后)</li>\n<li>组合型: n!&#x2F;(m!(n-m)!) (组合选数)</li>\n</ul>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><h2 id=\"子集\"><a href=\"#子集\" class=\"headerlink\" title=\"子集\"></a>子集</h2><p><a href=\"https://leetcode-cn.com/problems/subsets/\">LeetCode</a></p>\n<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>按数组index递归找出子集, 把找出的子集放入全局变量中. 每个元素在或不在子集中, 所以要分两种情况进行递归: 元素不在子集中, 直接index++; 元素在子集中, 将该元素添加到全局变量set中, 并且在递归后还原状态. 终止条件为index &#x3D; nums.size</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">subsets</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;    </span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)    </span><br><span class=\"line\">    set := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> findSubSet <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span> </span><br><span class=\"line\">    findSubSet = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(nums []<span class=\"type\">int</span>, index <span class=\"type\">int</span>)</span></span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 递归终止条件       </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index == <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 完成一次递归, 将当前set加入ans中            </span></span><br><span class=\"line\">            <span class=\"comment\">//注意这里需要对set进行一次copy </span></span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans, <span class=\"built_in\">append</span>([]<span class=\"type\">int</span>(<span class=\"literal\">nil</span>), set...))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 元素不在子集中, 继续递归      </span></span><br><span class=\"line\">        findSubSet(nums, index+<span class=\"number\">1</span>) </span><br><span class=\"line\">        <span class=\"comment\">// 元素在子集中, 将当前元素加入set中      </span></span><br><span class=\"line\">        set = <span class=\"built_in\">append</span>(set, nums[index]) </span><br><span class=\"line\">        findSubSet(nums, index+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 还原set      </span></span><br><span class=\"line\">        set = set[:<span class=\"built_in\">len</span>(set)<span class=\"number\">-1</span>] </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    findSubSet(nums, <span class=\"number\">0</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><p><a href=\"https://leetcode-cn.com/problems/combinations/\">LeetCode</a><br>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。示例:输入: n &#x3D; 4, k &#x3D; 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这题与上道题类似, 组合是子集的一部分, 即集合内的元素数量刚好为k</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">combine</span><span class=\"params\">(n <span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123; </span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)  </span><br><span class=\"line\">    set := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> findCombine <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>  </span><br><span class=\"line\">    findCombine = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(index <span class=\"type\">int</span>)</span></span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(set) &gt; k || index + n - index + <span class=\"number\">1</span> &lt; k &#123;   </span><br><span class=\"line\">            <span class=\"comment\">// 当前元素个数已大于k, 或者即使剩余元素全部选上, 都不够k个            </span></span><br><span class=\"line\">            <span class=\"comment\">//提前退出      </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> index == n + <span class=\"number\">1</span> &#123;    </span><br><span class=\"line\">            <span class=\"comment\">// 子集中元素个数为k         </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(set) == k &#123;     </span><br><span class=\"line\">                ans = <span class=\"built_in\">append</span>(ans, <span class=\"built_in\">append</span>([]<span class=\"type\">int</span>&#123;&#125;, set...))  </span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">            <span class=\"keyword\">return</span>     </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        findCombine(index + <span class=\"number\">1</span>)  </span><br><span class=\"line\">        set = <span class=\"built_in\">append</span>(set, index)</span><br><span class=\"line\">        findCombine(index + <span class=\"number\">1</span>)    </span><br><span class=\"line\">        set = set[:<span class=\"built_in\">len</span>(set) - <span class=\"number\">1</span>] </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findCombine(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。示例 1：输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2：输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]示例 3：输入：nums &#x3D; [1]输出：[[1]]</p>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>同上, 递归遍历每一层, 不过每一层不在是选择或不选择, 而是nums中的n个数作为候选项, 因此在递归内部需要迭代nums中的每个元素</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">permute</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)    </span><br><span class=\"line\">    used := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>, <span class=\"number\">0</span>) </span><br><span class=\"line\">    cur := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> findPermute <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>  </span><br><span class=\"line\">    findPermute = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(index <span class=\"type\">int</span>)</span></span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> index == <span class=\"built_in\">len</span>(nums) &#123;      </span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans, <span class=\"built_in\">append</span>([]<span class=\"type\">int</span>&#123;&#125;, cur...))      </span><br><span class=\"line\">            <span class=\"keyword\">return</span>      </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, i := <span class=\"keyword\">range</span> nums &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> used[i] == <span class=\"literal\">false</span> &#123;    </span><br><span class=\"line\">                used[i] = <span class=\"literal\">true</span>      </span><br><span class=\"line\">                cur = <span class=\"built_in\">append</span>(cur, i)     </span><br><span class=\"line\">                findPermute(index+<span class=\"number\">1</span>)  </span><br><span class=\"line\">                used[i] = <span class=\"literal\">false</span>  </span><br><span class=\"line\">                cur = cur[:<span class=\"built_in\">len</span>(cur) - <span class=\"number\">1</span>]      </span><br><span class=\"line\">            &#125;        </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    findPermute(<span class=\"number\">0</span>)   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"翻转二叉树\"><a href=\"#翻转二叉树\" class=\"headerlink\" title=\"翻转二叉树\"></a>翻转二叉树</h2><p><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">LeetCode</a> </p>\n<p>翻转一棵二叉树。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node. </span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int </span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode </span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">invertTree</span><span class=\"params\">(root *TreeNode)</span></span> *TreeNode &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>   </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    invertTree(root.Left)  </span><br><span class=\"line\">    invertTree(root.Right)   </span><br><span class=\"line\">    root.Left, root.Right = root.Right, root.Left </span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">    root&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证二叉搜索树\"><a href=\"#验证二叉搜索树\" class=\"headerlink\" title=\"验证二叉搜索树\"></a>验证二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">LeetCode</a><br>给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p>\n<ul>\n<li>节点的左子树只包含小于当前节点的数。</li>\n<li>节点的右子树只包含大于当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node. </span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int </span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode </span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode </span></span><br><span class=\"line\"><span class=\"comment\"> * &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NodeInfo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    min, max <span class=\"type\">int64</span>    </span><br><span class=\"line\">    isValid <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    r := isValid(root)  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.isValid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(root *TreeNode)</span></span> *NodeInfo &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;NodeInfo&#123;       </span><br><span class=\"line\">            min: math.MaxInt64,</span><br><span class=\"line\">            max: math.MinInt64,</span><br><span class=\"line\">            isValid: <span class=\"literal\">true</span>,  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    left := isValid(root.Left)  </span><br><span class=\"line\">    right := isValid(root.Right)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result NodeInfo </span><br><span class=\"line\">    </span><br><span class=\"line\">    result.max = <span class=\"type\">int64</span>(math.Max(<span class=\"type\">float64</span>(root.Val), math.Max(<span class=\"type\">float64</span>(left.max), <span class=\"type\">float64</span>(right.max))))  </span><br><span class=\"line\">    result.min = <span class=\"type\">int64</span>(math.Min(<span class=\"type\">float64</span>(root.Val), math.Min(<span class=\"type\">float64</span>(left.min), <span class=\"type\">float64</span>(right.min))))  </span><br><span class=\"line\">    result.isValid = left.isValid &amp;&amp; right.isValid &amp;&amp;              </span><br><span class=\"line\">                        left.max &lt; <span class=\"type\">int64</span>(root.Val) &amp;&amp; <span class=\"type\">int64</span>(root.Val) &lt; right.min </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;result&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树的最大深度\"><a href=\"#二叉树的最大深度\" class=\"headerlink\" title=\"二叉树的最大深度\"></a>二叉树的最大深度</h2><p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">LeetCode</a><br>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。</p>\n<h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><p>自底向上统计信息 (分治思想)最大深度 &#x3D; max(左子树最大深度+右子树最大深度) + 1</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node. </span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int </span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode </span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode </span></span><br><span class=\"line\"><span class=\"comment\"> * &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">int</span>(math.Max(<span class=\"type\">float64</span>(maxDepth(root.Left)), <span class=\"type\">float64</span>(maxDepth(root.Right)))) + <span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><p>自顶向下维护信息, 一种写法是维护全局变量, 每递归一层, 令其+1, 需要注意还原现场; 另一种写法是通过函数参数传入, 这种写法每次调用递归函数时, 都会把该参数压栈, 空间上回多消耗一些, 但是更容易编写</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node. </span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int </span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode </span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans <span class=\"type\">int</span>    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> depth <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode, <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    depth = <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(root *TreeNode, current <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;           </span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ans = <span class=\"type\">int</span>(math.Max(<span class=\"type\">float64</span>(ans), <span class=\"type\">float64</span>(current)))</span><br><span class=\"line\">        depth(root.Left, current+<span class=\"number\">1</span>)</span><br><span class=\"line\">        depth(root.Right, current+<span class=\"number\">1</span>) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    depth(root, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> current, ans <span class=\"type\">int</span> </span><br><span class=\"line\">    <span class=\"keyword\">var</span> depth <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    depth = <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(root *TreeNode)</span></span>  &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current++ </span><br><span class=\"line\">        ans = <span class=\"type\">int</span>(math.Max(<span class=\"type\">float64</span>(ans), <span class=\"type\">float64</span>(current)))        </span><br><span class=\"line\">        depth(root.Left) </span><br><span class=\"line\">        depth(root.Right)</span><br><span class=\"line\">        current--        <span class=\"comment\">// 还原现场    </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        depth(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"二叉树的最小深度\"><a href=\"#二叉树的最小深度\" class=\"headerlink\" title=\"二叉树的最小深度\"></a>二叉树的最小深度</h2><p><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\">LeetCode</a><br>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>与前一题最大深度类似, 不同的是递归结束条件为当前节点为叶子节点, 且在存在左或右子树的情况下进行递归</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否为空树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ans := math.MaxInt32</span><br><span class=\"line\">    <span class=\"keyword\">var</span> depth <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode, <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    depth = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode, current <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 已经保证root不为nil</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &#123;      <span class=\"comment\">// 叶子节点</span></span><br><span class=\"line\">            ans = <span class=\"type\">int</span>(math.Min(<span class=\"type\">float64</span>(ans), <span class=\"type\">float64</span>(current)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            depth(root.Left, current+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            depth(root.Right, current+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    depth(root, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h1><h2 id=\"Pow-x-n\"><a href=\"#Pow-x-n\" class=\"headerlink\" title=\"Pow(x, n)\"></a>Pow(x, n)</h2><p><a href=\"https://leetcode-cn.com/problems/powx-n/\">LeetCode</a><br>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myPow</span><span class=\"params\">(x <span class=\"type\">float64</span>, n <span class=\"type\">int</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> / myPow(x, -n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sub := myPow(x, n / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sub * sub</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sub * sub * x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"括号生成\"><a href=\"#括号生成\" class=\"headerlink\" title=\"括号生成\"></a>括号生成</h2><p><a href=\"https://leetcode-cn.com/problems/generate-parentheses/\">LeetCode</a><br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>\n<h3 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这题的关键在于子问题的划分, 把原问题划分为<code>(a)b</code>来进行递归求解</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= n; i++ &#123;</span><br><span class=\"line\">        result_a := generateParenthesis(i - <span class=\"number\">1</span>)</span><br><span class=\"line\">        result_b := generateParenthesis(n - i)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, a := <span class=\"keyword\">range</span> result_a &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _, b := <span class=\"keyword\">range</span> result_b &#123;</span><br><span class=\"line\">                ans = <span class=\"built_in\">append</span>(ans, <span class=\"string\">&quot;(&quot;</span> + a + <span class=\"string\">&quot;)&quot;</span> + b)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n","categories":[],"tags":["算法"]},{"title":"算法进阶(04) - 哈希、集合、映射","url":"https://blog.ranchocooper.com/2021/06/30/advanced-algorithm-04/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><h2 id=\"哈希表的原理\"><a href=\"#哈希表的原理\" class=\"headerlink\" title=\"哈希表的原理\"></a>哈希表的原理</h2><p>哈希表(Hash Table)又称散列表, 是一种可以通过<code>关键码</code>(key)直接进行访问的数据结构. 它由两部分组成</p>\n<ul>\n<li>一个数据结构, 通常是链表、数组</li>\n<li>Hash函数, 输入<code>关键码</code>, 返回对应数据的索引</li>\n</ul>\n<p>对外表现可以通过关键码直接访问, 如</p>\n<pre><code>hash_table[key] = value\n</code></pre>\n<p>实际上是对key进行了一次哈希运算之后, 从数据结构中定位到value    </p>\n<pre><code>data_structure[hash(key)] = value\n</code></pre>\n<p>所以设计哈希表的关键在于设计一个理想的Hash函数, 它能把复杂信息映射到较小的值域内, 作为索引. </p>\n<h2 id=\"哈希碰撞\"><a href=\"#哈希碰撞\" class=\"headerlink\" title=\"哈希碰撞\"></a>哈希碰撞</h2><p>哈希碰撞是指两个不同的key被计算出同样的哈希值, 好的哈希函数可以减少碰撞发生的几率, 让数据尽可能均匀地分布开散列是最常见的碰撞解决方案</p>\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><p><a href=\"https://leetcode-cn.com/problems/two-sum/description/\">LeetCode</a></p>\n<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">        another := target - nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> _, ok := m[another]; ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;m[another], i&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[nums[i]] = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"模拟行走机器人\"><a href=\"#模拟行走机器人\" class=\"headerlink\" title=\"模拟行走机器人\"></a>模拟行走机器人</h2><p><a href=\"https://leetcode-cn.com/problems/walking-robot-simulation/\">LeetCode</a></p>\n<p>机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：</p>\n<p>-2 ：向左转 90 度<br>-1 ：向右转 90 度<br>1 &lt;&#x3D; x &lt;&#x3D; 9 ：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] &#x3D; (xi, yi) 。</p>\n<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p>\n<p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）</p>\n<p>注意：</p>\n<p>北表示 +Y 方向。<br>东表示 +X 方向。<br>南表示 -Y 方向。<br>西表示 -X 方向。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>解题关键在于利用方向数组来进行方向转换</p>\n<h2 id=\"字母异位词分组\"><a href=\"#字母异位词分组\" class=\"headerlink\" title=\"字母异位词分组\"></a>字母异位词分组</h2><p><a href=\"https://leetcode-cn.com/problems/group-anagrams/\">LeetCode</a></p>\n<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\n<p>示例:</p>\n<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>[“ate”,”eat”,”tea”],<br>[“nat”,”tan”],<br>[“bat”]<br>]<br>说明：</p>\n<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>遍历输入, 对每个字符串的副本进行排序, 并将排序后的字符串作为key, 原字符串作为value保存到一个map中</p>\n<p>注意, Go语言对字符串的排序要特殊处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SortRunes []<span class=\"type\">rune</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s SortRunes)</span></span> Len() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s SortRunes)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[i] &lt; s[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s SortRunes)</span></span> Swap(i, j <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    s[i], s[j] = s[j], s[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">groupAnagrams</span><span class=\"params\">(strs []<span class=\"type\">string</span>)</span></span> [][]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    mapping, ans := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>][]<span class=\"type\">string</span>&#123;&#125;, [][]<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, str := <span class=\"keyword\">range</span> strs &#123;</span><br><span class=\"line\">        sorted := []<span class=\"type\">rune</span>(str)</span><br><span class=\"line\">        sort.Sort(SortRunes(sorted))</span><br><span class=\"line\">        value := mapping[<span class=\"type\">string</span>(sorted)]</span><br><span class=\"line\">        value = <span class=\"built_in\">append</span>(value, str)</span><br><span class=\"line\">        mapping[<span class=\"type\">string</span>(sorted)] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> mapping &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"串联所有单词的子串\"><a href=\"#串联所有单词的子串\" class=\"headerlink\" title=\"串联所有单词的子串\"></a>串联所有单词的子串</h2><p><a href=\"https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/\">LeetCode</a></p>\n<p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>\n<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这题的解法偏暴力, 先将所有的words转成映射, 然后以step为步进依次查看当前的单词是否在m中</p>\n<p>做完提交后才发现这题不讲武德, words里可能会有重复的单词. 所以在每次迭代i时都重新去构建映射m. 如果题目中的words不包含重复单词, 这种解法会快很多</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findSubstring</span><span class=\"params\">(s <span class=\"type\">string</span>, words []<span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    step := <span class=\"built_in\">len</span>(words[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    ans := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s) - <span class=\"built_in\">len</span>(words) * step + <span class=\"number\">1</span>; i++ &#123;</span><br><span class=\"line\">        flag := <span class=\"literal\">true</span></span><br><span class=\"line\">        m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, word := <span class=\"keyword\">range</span> words &#123;</span><br><span class=\"line\">            m[word]++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(words); j++ &#123;</span><br><span class=\"line\">            key := s[i+j*step: i+(j+<span class=\"number\">1</span>)*step]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> _, ok := m[key]; !ok &#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">false</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m[key]--</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m[key] &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">false</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans, i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LRU-缓存机制\"><a href=\"#LRU-缓存机制\" class=\"headerlink\" title=\"LRU 缓存机制\"></a>LRU 缓存机制</h2><p><a href=\"https://leetcode-cn.com/problems/lru-cache/\">LeetCode</a></p>\n<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>\n<p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LinkedNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    key, value <span class=\"type\">int</span></span><br><span class=\"line\">    prev, next *LinkedNode          <span class=\"comment\">// 双向链表</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    size, capacity <span class=\"type\">int</span></span><br><span class=\"line\">    cache <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkedNode</span><br><span class=\"line\">    head, tail *LinkedNode          <span class=\"comment\">// 保护节点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    l := LRUCache&#123;</span><br><span class=\"line\">        size: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: capacity,</span><br><span class=\"line\">        cache: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkedNode, <span class=\"number\">0</span>),</span><br><span class=\"line\">        head: &amp;LinkedNode&#123;&#125;,</span><br><span class=\"line\">        tail: &amp;LinkedNode&#123;&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置保护节点</span></span><br><span class=\"line\">    l.head.next = l.tail</span><br><span class=\"line\">    l.tail.prev = l.head</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> RemoveNode(node *LinkedNode) &#123;</span><br><span class=\"line\">    node.prev.next = node.next</span><br><span class=\"line\">    node.next.prev = node.prev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> InsertFront(node *LinkedNode) &#123;</span><br><span class=\"line\">    node.prev = this.head</span><br><span class=\"line\">    node.next = this.head.next</span><br><span class=\"line\">    this.head.next.prev = node</span><br><span class=\"line\">    this.head.next = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.RemoveNode(this.cache[key])</span><br><span class=\"line\">    this.InsertFront(this.cache[key])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.cache[key].value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := this.cache[key]; ok &#123;</span><br><span class=\"line\">        this.cache[key].value = value</span><br><span class=\"line\">        this.RemoveNode(this.cache[key])</span><br><span class=\"line\">        this.InsertFront(this.cache[key])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node := &amp;LinkedNode&#123;</span><br><span class=\"line\">            key: key,</span><br><span class=\"line\">            value: value,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.cache[key] = node</span><br><span class=\"line\">        this.InsertFront(node)</span><br><span class=\"line\">        this.size++</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> this.size &gt; this.capacity &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(this.cache, this.tail.prev.key)</span><br><span class=\"line\">            this.RemoveNode(this.tail.prev)</span><br><span class=\"line\">            this.size--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["算法"]},{"title":"Redis中的高性能IO模型","url":"https://blog.ranchocooper.com/2021/06/29/io-module-in-redis/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p>本文主要探讨一个Redis中的经典问题: 为什么单线程的Redis能这么快?</p>\n<p>首先, 要厘清一个事实, 我们通常所说的Redis是单线程, 主要是指Redis的网络IO和键值对读写都是由一个线程来完成的. 而Redis的其他功能, 比如持久化、异步删除、集群数据同步等, 其实是由额外的线程执行的. 所以, 严格来说Redis并不是单线程的</p>\n<h1 id=\"Redis为什么用单线程\"><a href=\"#Redis为什么用单线程\" class=\"headerlink\" title=\"Redis为什么用单线程\"></a>Redis为什么用单线程</h1><h2 id=\"多线程的开销\"><a href=\"#多线程的开销\" class=\"headerlink\" title=\"多线程的开销\"></a>多线程的开销</h2><p>日常写程序, 经常会听到一种说法: 使用多线程, 可以增加系统吞吐率, 或是可以增加系统扩展性. 的确, 对于一个多线程的系统来说, 在有合理的资源分配的情况下, 可以提升系统同时处理的请求数, 如下面的左图所示</p>\n<p>但是, 通常情况下, 在外面采用多线程后, 如果没有良好的系统设计, 实际得到的结果, 其实是像右图所展示的那样. 刚开始增加线程数时, 系统吞吐会增加, 但是, 当超过一定的线程数时, 系统的吞吐就增长缓慢, 有时甚至还会出现下降的情况.</p>\n<p><img src=\"/a.png\"></p>\n<p>之所以会出现这种情况, 关键的瓶颈在于当多个线程操作共享资源时, 为了保证一致性, 就需要额外的机制保证并发读写的正确性, 这样一来就会带来额外的开销. 并发访问控制是多线程开发中的一个难点问题, 如果没有精细的设计, 比如只是简单地采用一个粗粒度的互斥锁, 就会出现不理想的结果: 即使增加了线程数量, 大部分线程都在等待互斥锁, 并行变串行, 系统的吞吐并没有随之增加. 另外, 采用多线程开发一般会引入同步原语来保护共享资源的并发访问, 这也会降低系统代码的可维护性和易调试性. 为了避免这些问题, Redis直接采用了单线程模式</p>\n<h1 id=\"单线程Redis为什么那么快\"><a href=\"#单线程Redis为什么那么快\" class=\"headerlink\" title=\"单线程Redis为什么那么快?\"></a>单线程Redis为什么那么快?</h1><p>通常来说, 单线程的处理能力要比多线程差, 但Redis却能使用单线程模型达到每秒数十万级别的处理能力. 一方面因为Redis的大部分操作都在内存中完成, 再加上它采用了高效的数据结构, 例如哈希表和跳表. 另一方面, 就是Redis采用了<code>多路复用机制</code>, 使其在网络IO操作中能并发处理大量的客户端请求, 实现高吞吐率.</p>\n<h2 id=\"基本IO模型与阻塞点\"><a href=\"#基本IO模型与阻塞点\" class=\"headerlink\" title=\"基本IO模型与阻塞点\"></a>基本IO模型与阻塞点</h2><p>在一次Redis命令的处理过程中, 涉及的网络操作包括监听请求(bind&#x2F;listen), 建立连接(accept), 从socket中读取请求(recv), 最后返回结果(send). 在这些网络IO操作中, 潜在的阻塞点分别是accept()和recv()</p>\n<p><img src=\"/b.png\"></p>\n<h2 id=\"基于多路复用的IO模型\"><a href=\"#基于多路复用的IO模型\" class=\"headerlink\" title=\"基于多路复用的IO模型\"></a>基于多路复用的IO模型</h2><p>Linux中的IO多路复用是指一个线程处理多个IO流, 也就是select&#x2F;epoll机制. 改机制允许内核同事存在多个监听套接字和已连接套接字, 内核会一直监听这些套接字上的连接请求, 一旦有请求到达就会交给Redis线程处理. 这样, Redis就不会阻塞在某个特定的客户端请求上</p>\n<p><img src=\"/c.png\"><br>select&#x2F;epoll提供了基于事件的回调机制, 当select&#x2F;epoll检测到FD上有请求到达时, 就会触发相应的事件. 这些事件会被放进一个事件队列, Redis线程不断处理该事件队列. 这样一来, Redis无需一直轮训是否有请求发生, 可以避免CPU资源浪费</p>\n","categories":[],"tags":["存储中间件","Redis"]},{"title":"算法进阶(03) - 前缀和、差分、双指针扫描","url":"https://blog.ranchocooper.com/2021/06/28/advanced-algorithm-03/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h1><p>对于一维数组A</p>\n<ul>\n<li>前缀和数组: S[i] &#x3D; S[i - 1] + A[i]</li>\n<li>字段和: Sum[l, r] &#x3D; S[r] - S[l - 1]</li>\n<li>当A中元素都是非负数时, 前缀和数组S单调递增</li>\n</ul>\n<h2 id=\"统计「优美子数组」\"><a href=\"#统计「优美子数组」\" class=\"headerlink\" title=\"统计「优美子数组」\"></a>统计「优美子数组」</h2><p><a href=\"https://leetcode-cn.com/problems/count-number-of-nice-subarrays/\">LeetCode</a></p>\n<p>给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>首先, 这题和数组中元素的值无关, 我们可以先把数组进行转换: 奇数为1, 偶数为零, 然后构建前缀和数组S. 要得到<code>子数组中恰好有K个奇数</code>的数量, 也就是求S[i] - S[j] &#x3D; k的数量. 所以只需要用一个计数数组统计S中每个值的个数, 枚举右端点i, 看一下等于S[i] - k的值的个数就可以了</p>\n<p>func numberOfSubarrays(nums []int, k int) int {<br>    &#x2F;&#x2F; 向nums数组头部插入0, 方便下标索引<br>    nums &#x3D; append([]int{0}, nums…)<br>    n :&#x3D; len(nums)<br>    s :&#x3D; make([]int, n)<br>    &#x2F;&#x2F; 构建nums的前缀和数组, 并进行奇偶转换, 注意这里是从i &#x3D; 1开始<br>    for i :&#x3D; 1; i &lt; n; i++ {<br>        s[i] &#x3D; s[i - 1] + nums[i]%2<br>    }<br>    &#x2F;&#x2F; 构建前缀和值的统计数组<br>    count :&#x3D; make([]int, n)<br>    for i :&#x3D; 0; i &lt; n; i++ {<br>        count[s[i]] +&#x3D; 1<br>    }<br>    &#x2F;&#x2F; 对于每个r(1<del>n), 考虑有几个l(1</del>r)满足s[r] - s[l - 1] &#x3D; k<br>    &#x2F;&#x2F; 对于每个i(1<del>n), 考虑有几个j(1</del>r-1)满足s[i] - s[j] &#x3D; k, 即<br>    &#x2F;&#x2F; 对于每个i(1<del>n), 考虑有几个j(1</del>r-1)满足s[i] - k &#x3D; s[j]<br>    &#x2F;&#x2F; 也就是对于每个i, 考虑有几个s[j]等于s[i] - k<br>    var ans int<br>    for i :&#x3D; 0; i &lt; n; i++ {<br>        if s[i] - k &gt;&#x3D; 0 {<br>            ans +&#x3D; count[s[i] - k]<br>        }<br>    }<br>    return ans<br>}</p>\n<h1 id=\"二维前缀和\"><a href=\"#二维前缀和\" class=\"headerlink\" title=\"二维前缀和\"></a>二维前缀和</h1><p>对于二维数组A</p>\n<ul>\n<li>前缀和数组S[i][j] &#x3D; S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j]</li>\n<li>子矩阵和(以(p, q)为左上角, 以(i, j)为右下角的子矩阵的和)<br>Sum(p, q, i, j) &#x3D; S[i][j] - S[i][q-1] - S[p-1][j] + S[p-1][q-1]</li>\n<li>复杂度: 预处理O(N2^), 询问O(1)</li>\n</ul>\n<h2 id=\"二维区域和检索-矩阵不可变\"><a href=\"#二维区域和检索-矩阵不可变\" class=\"headerlink\" title=\"二维区域和检索 - 矩阵不可变\"></a>二维区域和检索 - 矩阵不可变</h2><p><a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">LeetCode</a></p>\n<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。</p>\n<h1 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h1><h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>对于一维数组A, 其差分数组B, 有</p>\n<ul>\n<li>B1 &#x3D; A1, B[i] &#x3D; A[i] - A[i-1]</li>\n<li>差分数组B的前缀和数组就是原数组A</li>\n</ul>\n<h2 id=\"航班预订统计\"><a href=\"#航班预订统计\" class=\"headerlink\" title=\"航班预订统计\"></a>航班预订统计</h2><p><a href=\"https://leetcode-cn.com/problems/corporate-flight-bookings/\">LeetCode</a></p>\n<p>这里有 n 个航班，它们分别从 1 到 n 进行编号。有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] &#x3D; [firsti, lasti, seatsi]<br>意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p>\n<p>请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">corpFlightBookings</span><span class=\"params\">(bookings [][]<span class=\"type\">int</span>, n <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;   </span><br><span class=\"line\">    delta := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n + <span class=\"number\">2</span>) <span class=\"comment\">// 差分数组要开0~n+1   </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, booking := <span class=\"keyword\">range</span> bookings &#123;       </span><br><span class=\"line\">        first, last, seats := booking[<span class=\"number\">0</span>], booking[<span class=\"number\">1</span>], booking[<span class=\"number\">2</span>]       </span><br><span class=\"line\">        <span class=\"comment\">// 差分模板       </span></span><br><span class=\"line\">        delta[first] += seats</span><br><span class=\"line\">        delta[last + <span class=\"number\">1</span>] -= seats  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    sum := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n + <span class=\"number\">1</span>)   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= n; i++ &#123;      </span><br><span class=\"line\">        sum[i] = sum[i - <span class=\"number\">1</span>] + delta[i]  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"comment\">// 将sum中元素往前挪一位   </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= n; i++ &#123;       </span><br><span class=\"line\">        sum[i - <span class=\"number\">1</span>] = sum[i]   </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum[:<span class=\"built_in\">len</span>(sum) - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最大子序和\"><a href=\"#最大子序和\" class=\"headerlink\" title=\"最大子序和\"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>解法一: 前缀和 + 前缀最小值求出前缀和数组S, 枚举右端点i, 需要找到i之前的一个j, 使得S[i] - S[j]最大, 也就是要让S[j]最小, 再维护一个S的前缀最小值即可</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;   </span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)   </span><br><span class=\"line\">    sum := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n + <span class=\"number\">1</span>)   </span><br><span class=\"line\">    <span class=\"comment\">// 构建前缀和   </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= n; i++ &#123;       </span><br><span class=\"line\">        sum[i] = sum[i - <span class=\"number\">1</span>] + nums[i - <span class=\"number\">1</span>]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ans := math.MinInt32   </span><br><span class=\"line\">    preMin := sum[<span class=\"number\">0</span>]   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= n; i++ &#123;      </span><br><span class=\"line\">        ans = <span class=\"type\">int</span>(math.Max(<span class=\"type\">float64</span>(ans), <span class=\"type\">float64</span>(sum[i] - preMin)))      </span><br><span class=\"line\">        preMin = <span class=\"type\">int</span>(math.Min(<span class=\"type\">float64</span>(preMin), <span class=\"type\">float64</span>(sum[i])))  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"双指针扫描\"><a href=\"#双指针扫描\" class=\"headerlink\" title=\"双指针扫描\"></a>双指针扫描</h1><p>双指针扫描一般用于解决 基于<code>子段</code>的统计问题这类题目的朴素做法都是两重循环的枚举, 枚举左端点l&#x2F;右端点r.<br>(时间复杂度O(N^2))优化手法都是找到枚举中的冗余部分, 并将其去除通常的优化策略有:</p>\n<ul>\n<li>固定右端点, 看左端点的取值范围</li>\n<li>移动一个端点, 看另一个端点的变化情况<ul>\n<li>例如一个端点跟随另一个端点单调移动, 像一个<code>滑动窗口</code></li>\n<li>此时可以考虑<code>双指针扫描</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"两数之和-II-输入有序数组\"><a href=\"#两数之和-II-输入有序数组\" class=\"headerlink\" title=\"两数之和 II - 输入有序数组\"></a>两数之和 II - 输入有序数组</h2><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">LeetCode</a></p>\n<p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;&#x3D; answer[0] &lt; answer[1] &lt;&#x3D; numbers.length 。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">j := <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(numbers); i++ &#123;</span><br><span class=\"line\"><span class=\"comment\">// 当i增加, 若要满足numbers[i] + numbers[j] == target, j必然要减小       </span></span><br><span class=\"line\"><span class=\"comment\">// 所以可以固定i, 令j不断减小       </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ; i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target; j-- &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> i &lt; j &amp;&amp; numbers[i] + numbers[j] == target &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>&#125;      </span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三数之和\"><a href=\"#三数之和\" class=\"headerlink\" title=\"三数之和\"></a>三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>复用两数之和</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">threeSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 排序   </span></span><br><span class=\"line\">sort.Sort(sort.IntSlice(nums))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\"><span class=\"comment\">// 去重       </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">jks := twoSum(nums, i + <span class=\"number\">1</span>, -nums[i])</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, jk := <span class=\"keyword\">range</span> jks &#123;</span><br><span class=\"line\">ans = <span class=\"built_in\">append</span>(ans, []<span class=\"type\">int</span>&#123;nums[i], jk[<span class=\"number\">0</span>], jk[<span class=\"number\">1</span>]&#125;)</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, start, target <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">ans := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">j := <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := start; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\"><span class=\"comment\">// 去重       </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> i &gt; start &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ; i &lt; j &amp;&amp; nums[i] + nums[j] &gt; target; &#123;</span><br><span class=\"line\">j--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> i &lt; j &amp;&amp; nums[i] + nums[j] == target &#123;</span><br><span class=\"line\">ans = <span class=\"built_in\">append</span>(ans, []<span class=\"type\">int</span>&#123;nums[i], nums[j]&#125;)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"盛最多水的容器\"><a href=\"#盛最多水的容器\" class=\"headerlink\" title=\"盛最多水的容器\"></a>盛最多水的容器</h2><p><a href=\"https://leetcode-cn.com/problems/container-with-most-water/\">LeetCode</a></p>\n<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器。</p>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>盛水多少是由短的那根决定的, 我们可以用i&#x2F;j分别从头尾向中间夹逼</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxArea</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">ans, i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height) - <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// i, j从两端向中间夹逼   </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ; i &lt; j; &#123;</span><br><span class=\"line\">fi := <span class=\"type\">float64</span>(height[i])</span><br><span class=\"line\">fj := <span class=\"type\">float64</span>(height[j])</span><br><span class=\"line\">fa := <span class=\"type\">float64</span>(ans)</span><br><span class=\"line\">ans = <span class=\"type\">int</span>(math.Max(fa, <span class=\"type\">float64</span>(j - i) * math.Min(fi, fj)))</span><br><span class=\"line\"><span class=\"keyword\">if</span> fi &lt; fj &#123;</span><br><span class=\"line\">i++</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">j--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["算法"]},{"title":"算法进阶(02) - 栈、队列","url":"https://blog.ranchocooper.com/2021/06/22/advanced-algorithm-02/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><h2 id=\"栈-x2F-队列\"><a href=\"#栈-x2F-队列\" class=\"headerlink\" title=\"栈&#x2F;队列\"></a>栈&#x2F;队列</h2><ul>\n<li>push(入栈&#x2F;入队): O(1)</li>\n<li>pop(出栈&#x2F;出队): O(1)</li>\n<li>access(访问栈顶&#x2F;访问队头): O(1)</li>\n</ul>\n<h2 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h2><ul>\n<li>队头&#x2F;队尾的插入&#x2F;删除&#x2F;访问, 都是O(1)</li>\n</ul>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><ul>\n<li>访问最值: O(1)</li>\n<li>插入: 一般是O(logN), 一些高级的数据结构可以做到O(1)</li>\n<li>取最值: O(logN)</li>\n</ul>\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><h2 id=\"用切片实现栈\"><a href=\"#用切片实现栈\" class=\"headerlink\" title=\"用切片实现栈\"></a>用切片实现栈</h2><p>因为Golang中没有现成的栈可以开箱即用, 这里用切片简单实现一下, 作为模板以备不时之需</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    lock sync.RWMutex</span><br><span class=\"line\">    slice []<span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Size() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s.slice)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.Size() == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Push(value <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">    s.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.slice = <span class=\"built_in\">append</span>(s.slice, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Pop() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;stack is empty&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.slice = s.slice[:s.Size() - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Top() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.lock.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.lock.RUnlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.slice[<span class=\"built_in\">len</span>(s.slice) - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有效的括号\"><a href=\"#有效的括号\" class=\"headerlink\" title=\"有效的括号\"></a>有效的括号</h2><p><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">LeetCode</a></p>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>利用栈的先进后出特性, 遇到左括号入栈, 遇到右括号则先与栈顶元素进行配对, 如果配对成功则出栈, 配对失败或最终栈不为空则返回false. 为了方便配对, 我们可以维护一个map, 其中key是右括号, value是左括号</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) % <span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若字符串长度为奇数, 一定配对失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mapping := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;)&quot;</span>: <span class=\"string\">&quot;(&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;]&quot;</span>: <span class=\"string\">&quot;[&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;&#125;&quot;</span>: <span class=\"string\">&quot;&#123;&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []<span class=\"type\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">        c := <span class=\"type\">string</span>(c)  <span class=\"comment\">// 这里需要转换下类型, 否则编译不通过</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> _, ok := mapping[c]; ok &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遇到右括号, 进行配对判定</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] == mapping[c] &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 出栈</span></span><br><span class=\"line\">                    stack = stack[:<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 左括号, 进行入栈</span></span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, c)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"逆波兰表达式求值\"><a href=\"#逆波兰表达式求值\" class=\"headerlink\" title=\"逆波兰表达式求值\"></a>逆波兰表达式求值</h2><p><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">LeetCode</a></p>\n<p>根据 逆波兰表示法，求表达式的值。</p>\n<p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n<p>说明：</p>\n<p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>遇到数字则入栈, 遇到操作符先将栈顶两个元素出栈, 然后进行计算</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    lock sync.RWMutex</span><br><span class=\"line\">    slice []<span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Size() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s.slice)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.Size() == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Push(value <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">    s.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.slice = <span class=\"built_in\">append</span>(s.slice, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Pop() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;stack is empty&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> s.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    s.slice = s.slice[:s.Size() - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span> Top() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.slice[<span class=\"built_in\">len</span>(s.slice) - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calculate</span><span class=\"params\">(l, r, op <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    a, _ := strconv.ParseInt(l, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    b, _ := strconv.ParseInt(r, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> op &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">int</span>(a + b)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">int</span>(a - b)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">int</span>(a * b)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">int</span>(a / b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evalRPN</span><span class=\"params\">(tokens []<span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s Stack</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, token := <span class=\"keyword\">range</span> tokens &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token == <span class=\"string\">&quot;+&quot;</span> || token == <span class=\"string\">&quot;-&quot;</span> || token == <span class=\"string\">&quot;*&quot;</span> || token == <span class=\"string\">&quot;/&quot;</span> &#123;</span><br><span class=\"line\">            b := s.Top()</span><br><span class=\"line\">            s.Pop()</span><br><span class=\"line\">            a := s.Top()</span><br><span class=\"line\">            s.Pop()</span><br><span class=\"line\">            s.Push(strconv.Itoa(calculate(a, b, token)))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            s.Push(token)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r, _ := strconv.ParseInt(s.Top(), <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">int</span>(r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","categories":[],"tags":["算法"]},{"title":"Redis中的数据结构","url":"https://blog.ranchocooper.com/2021/06/21/data-structure-in-redis/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"Redis为什么这么快\"><a href=\"#Redis为什么这么快\" class=\"headerlink\" title=\"Redis为什么这么快?\"></a>Redis为什么这么快?</h1><p>时至今日, 可以选择的数据库有很多, 为什么Redis能有这么突出的表现呢<br>一方面是因为它是内存数据库, 所有的操作都在内存上完成. 另一方面, 这要归功于它的数据结构.<br>Redis一共支持五种数据类型, 包括String(字符串), List(列表), Hash(哈希), Set(集合)和Sorted Set(有序集合). 而它们的底层实现数据结构其实有六种, 分别是简单动态字符串, 整数数组, 双向链表, 压缩列表, 哈希表和跳表. 它们和五种数据类型的对应关系如下图所示:</p>\n<p><img src=\"/a.png\"></p>\n<p>可以看到, String类型的底层只有一种数据结构, 而List&#x2F;Hash&#x2F;Set&#x2F;Sorted Set都有两种底层实现结构. 通常情况下我们把这四种类型成为集合类型, 它们的特点是一个键对应了一个集合的数据.</p>\n<h1 id=\"如何组织键和值\"><a href=\"#如何组织键和值\" class=\"headerlink\" title=\"如何组织键和值?\"></a>如何组织键和值?</h1><p>为了实现从键到值的快速访问, Redis使用了一个哈希表来保存所有键值对. 一个哈希表其实就是一个数组, 数组的每个元素称为一个哈希桶, 每个哈希桶中保存了键值对数据. 哈希桶中的元素并不是值本身, 而是指向具体值的指针</p>\n<p><img src=\"/b.png\"></p>\n<p>使用哈希表最大的好处很明显, 就是可以让我们以O(1)的时间复杂度来快速找到键值对</p>\n<h1 id=\"为什么哈希操作变慢了\"><a href=\"#为什么哈希操作变慢了\" class=\"headerlink\" title=\"为什么哈希操作变慢了?\"></a>为什么哈希操作变慢了?</h1><p>但是, 当你往Redis中写入大量数据后, 可能会发现有的操作突然变慢了, 这是因为哈希表的潜在风险点 —- 哈希冲突问题和rehash操作可能带来的阻塞.</p>\n<p>Redis使用链式哈希来解决哈希冲突, 所谓链式哈希, 就是指同一个哈希桶中的多个元素用一个链表来保存, 它们之间依次用指针连接. </p>\n<p><img src=\"/c.png\"></p>\n<p>但即使如此, 仍然存在一个问题, 如果哈希表写入的数据越来越多, 哈希冲突也会越来越多, 这就导致某些哈希冲突链过长, 进而导致在这个链上查找元素耗时变长. 所以, Redis会对哈希表做rehash操作, 也及时增加现有的哈希桶数量, 让entry元素更加均匀地分散在哈希桶之间, 减少单个哈希桶中的元素数量, 从而减少哈希冲突的发生.</p>\n<p>为了使rehash操作更高效, Redis默认使用了两个全局哈希表. 一开始, 当你插入数据时, 默认使用哈希表1, 此时哈希表2并没有分配空间. 随着数据量增加, Redis开始执行rehash, 这个过程分为三步:</p>\n<pre><code>1. 为哈希表2分配更大的空间, 例如当前哈希表1的两倍大小\n2. 将哈希表1中的数据重新映射到哈希表2中\n3. 释放哈希表1的空间, 并留作下一次rehash时备用\n</code></pre>\n<p>在这个过程中, 第二步涉及大量的数据拷贝, 如果一次性把哈希表1中的数据全都迁移到表2中, 会导致Redis线程阻塞. 为了避免这个问题, Redis采用了渐进式rehash. 简单来说, 就是在进行第二步数据拷贝时, Redis仍然正常处理客户端请求, 但是每处理一个请求, 就把对应的哈希桶上的所有entry拷贝到哈希表2中; 等处理下一个请求时, 再迁移对应数据</p>\n<p><img src=\"/d.png\"></p>\n<p>这样一来, 原本大量的迁移开销被分摊到了多次处理请求的过程中, 避免了耗时操作, 保证了数据的快速访问.</p>\n<h1 id=\"特殊的数据结构\"><a href=\"#特殊的数据结构\" class=\"headerlink\" title=\"特殊的数据结构\"></a>特殊的数据结构</h1><p>在集合类型的物种底层数据结构中, 压缩列表和跳表比较少见.</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表实际上类似于一个数据, 和数组不同的是压缩列表在表头有三个字段<code>zlbytes</code>, <code>zltail</code>和<code>zllen</code>, 分别表示列表长度&#x2F;列表尾部的偏移量和列表中的entry数量. 在压缩列表表尾还有一个<code>zlend</code>, 表示列表结束</p>\n<p><img src=\"/e.png\"></p>\n<p>在压缩列表中, 如果我们要查找第一个元素和最后一个元素, 可以通过表头的三个字段直接定位, 复杂度是O(1). 而查找其他元素时只能逐个遍历, 此时复杂度是O(N).</p>\n<h2 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h2><p>跳表是在链表的基础上, 增加了多级索引, 通过索引位置的快速跳转, 实现数据的快速定位, 如图所示</p>\n<p><img src=\"/f.png\"></p>\n<p>跳表的时间复杂度是O(logN)</p>\n<h1 id=\"不同操作的时间复杂度\"><a href=\"#不同操作的时间复杂度\" class=\"headerlink\" title=\"不同操作的时间复杂度\"></a>不同操作的时间复杂度</h1><h2 id=\"单元素操作\"><a href=\"#单元素操作\" class=\"headerlink\" title=\"单元素操作\"></a>单元素操作</h2><p>每一种集合类型对单个数据的增删改查操作的复杂度, 由实际集合所使用的数据结构决定. 例如对Hash类型而言, 使用压缩列表时, <code>HGET</code>&#x2F;<code>HSET</code>和<code>HDEL</code>等操作的复杂度是O(N), 如果是对哈希表操作, 它们的复杂度就是O(1); 同样, 对Set类型来说, 当使用整数数组作为底层数据结构时, <code>SADD</code>&#x2F;<code>SREM</code>&#x2F;<code>SRANDMEMBER</code>等操作的复杂度是O(N), 当使用哈希表时, 复杂度就是O(1)</p>\n<h2 id=\"范围操作\"><a href=\"#范围操作\" class=\"headerlink\" title=\"范围操作\"></a>范围操作</h2><p>范围操作是指集合类型中的遍历操作, 可以返回集合中的所有数据比如Hash类型的<code>HGETALL</code>和Set类型的<code>SMEMBERS</code>, 或者是返回一个范围内的部分数据, 比如List类型的<code>LRANGE</code>和ZSet类型的<code>ZRANGE</code>, 这类操作的复杂度一般都是O(N), 我们应该尽量避免这类耗时操作</p>\n<p>不过Redis从2.8版本开始提供<code>SCAN</code>系列操作, 这类操作实现了渐进式遍历, 每次只返回有限数量的数据, 这样就避免了一次性返回所有元素而导致Redis阻塞.</p>\n<h2 id=\"统计操作\"><a href=\"#统计操作\" class=\"headerlink\" title=\"统计操作\"></a>统计操作</h2><p>这类操作一般复杂度都是O(1), 这是因为压缩列表&#x2F;双向链表&#x2F;整数数组等数据结构中专门记录了元素的个数统计, 因此可以高效地完成相关操作.</p>\n<h2 id=\"例外情况\"><a href=\"#例外情况\" class=\"headerlink\" title=\"例外情况\"></a>例外情况</h2><p>压缩列表和双向链表都会记录表头和表尾的偏移量, 这样一来, 对于List类型的<code>LPOP</code>&#x2F;<code>RPOP</code>&#x2F;<code>LPUSH</code>和<code>RPUSH</code>等操作而言, 它们的复杂度也只有O(1).</p>\n<h1 id=\"为什么使用整数数组和压缩列表\"><a href=\"#为什么使用整数数组和压缩列表\" class=\"headerlink\" title=\"为什么使用整数数组和压缩列表?\"></a>为什么使用整数数组和压缩列表?</h1><p>整数数组和压缩列表在查找的时间复杂度方面并没有很大的优势, 为什么Redis还会把它们作为底层数据结构呢? 这有两方面原因</p>\n<pre><code>1. 内存利用率, 数据和压缩列表都是紧凑的数据结构, 它们比链表占用更少的内存. \n    Redis是内存数据库, 要做到尽可能的优化, 提高内存的利用率\n2. 数组对CPU高速缓存的支持更加友好, 所以Redis在设计时, 在集合数据量较小默认采用内存紧凑排列的方式存储, 同时利用CPU高速缓存不会降低访问速度. \n    当数据元素超过设定阈值后, 避免查询时间复杂度过高, 转为哈希表和跳表来存储数据, 保证查询效率\n</code></pre>\n","categories":[],"tags":["存储中间件","Redis"]},{"title":"算法进阶(01) - 数组、链表","url":"https://blog.ranchocooper.com/2021/06/20/advanced-algorithm-01/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h2 id=\"合并两个有序数组\"><a href=\"#合并两个有序数组\" class=\"headerlink\" title=\"合并两个有序数组\"></a>合并两个有序数组</h2><p><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\">LeetCode</a></p>\n<p>给你两个有序整数数组<code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到<code>nums1</code>中，使 <code>nums1</code> 成为一个有序数组。</p>\n<p>初始化<code>nums1</code> 和 <code>nums2</code> 的元素数量分别为<code>m</code> 和 <code>n</code> 。你可以假设<code>nums1</code> 的空间大小等于<code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>nums1有足够空间容纳所有数组元素, 用k从m+n-1处开始向前遍历nums1, 然后分别用i, j从后往前遍历两个数组, 并将大的元素填入k的位置, 时间复杂度为O(n)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"type\">int</span>, m <span class=\"type\">int</span>, nums2 []<span class=\"type\">int</span>, n <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    i := m <span class=\"number\">-1</span></span><br><span class=\"line\">    j := n - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k := m + n - <span class=\"number\">1</span>; k &gt;=<span class=\"number\">0</span>; k-- &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j &lt; <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; nums1[i] &gt;= nums2[j]) &#123;</span><br><span class=\"line\">            nums1[k] = nums1[i]     </span><br><span class=\"line\">            i--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nums1[k] = nums1[j]</span><br><span class=\"line\">            j--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除有序数组中的重复项\"><a href=\"#删除有序数组中的重复项\" class=\"headerlink\" title=\"删除有序数组中的重复项\"></a>删除有序数组中的重复项</h2><p><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\">LeetCode</a></p>\n<p>给你一个有序数组 <code>nums</code> ，请你 <code>原地</code> 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 <code>原地</code> 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>遍历数组并判断i与i-1处元素是否相等, 并用n标记下标, 如果元素不相等, 将i处元素填入n</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> || nums[i - <span class=\"number\">1</span>] != nums[i] &#123;</span><br><span class=\"line\">            nums[n] = nums[i]</span><br><span class=\"line\">            n++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"移动零\"><a href=\"#移动零\" class=\"headerlink\" title=\"移动零\"></a>移动零</h2><p><a href=\"https://leetcode-cn.com/problems/move-zeroes/\">LeetCode</a></p>\n<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>同上题, 遍历数组并判断i处元素是否为0, 并用n来标记下标, 如果不为0则将该元素填入n处</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    n := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            nums[n] = nums[i]</span><br><span class=\"line\">            n++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将剩余的元素全部置0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">        nums[i] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h1><h2 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h2><p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">LeetCode</a></p>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>遍历链表, 并改变指向, 注意操作顺序</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseList</span><span class=\"params\">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> last *ListNode</span><br><span class=\"line\">    <span class=\"keyword\">for</span> head != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        next := head.Next</span><br><span class=\"line\">        head.next = last</span><br><span class=\"line\">        last = head</span><br><span class=\"line\">        head = next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h2><p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">LeetCode</a></p>\n<p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n<h3 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>通过快慢指针遍历链表, 如果两个指针相遇, 则有环</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    fast := head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> fast != <span class=\"literal\">nil</span> &amp;&amp; fast.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fast = fast.Next.Next</span><br><span class=\"line\">        head = head.Next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fast == head &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;     <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["算法"]},{"title":"在JUnit中定制Runner","url":"https://blog.ranchocooper.com/2019/05/29/junit4-customer-runners/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文将快速介绍如何在<code>JUnit</code>测试框架中使用自定义<code>Runner</code>来运行单测<br>当前, 这需要配合<code>@RunWith</code>注解</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>首先, 添加项目依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;<span class=\"number\">4.12</span>&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现Runner\"><a href=\"#实现Runner\" class=\"headerlink\" title=\"实现Runner\"></a>实现Runner</h2><p>JUnit框架提供了抽象类<code>Runner</code>, 它定义了两个抽象方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Description <span class=\"title function_\">getDescription</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(RunNotifier var1)</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>另外, 它还需要实现<code>Describable</code>接口, 即实现<code>getDescription()</code> 方法<br>接下来我们实现一个<code>CustomerRunner</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.Description;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.Runner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.notification.RunNotifier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> rancho</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019-05-29</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerRunner</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Runner</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class testedClass;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CustomerRunner</span><span class=\"params\">(Class testedClass)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.testedClass = testedClass;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * implements Describable interface</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Description</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Description <span class=\"title function_\">getDescription</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Description.createTestDescription(testedClass, <span class=\"string\">&quot;A Customer runner&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * invoke the target tested methods using reflection</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> notifier used for firing events that have information about the test progress</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(RunNotifier notifier)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;running the tests based on CustomerRunner&quot;</span> + testedClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">testedObject</span> <span class=\"operator\">=</span> testedClass.newInstance();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : testedClass.getMethods()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.isAnnotationPresent(Test.class)) &#123;</span><br><span class=\"line\">                    notifier.fireTestStarted(Description.createTestDescription(testedClass, method.getName()));</span><br><span class=\"line\">                    method.invoke(testedObject);</span><br><span class=\"line\">                    notifier.fireTestFinished(Description.createTestDescription(testedClass, method.getName()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个实现类中, 我们定义了一个接受类参数的构造函数, 这是JUnit框架对Runner的规范. 单测运行时, JUnit会将目标类传给Runner的构造器.<br><code>getDescription</code>方法用于返回描述信息, 而最关键的就在于<code>run</code>方法实现, 通过反射来调用目标方法.<br>另外, 通过<code>run</code>方法的入参<code>RunNotifier</code>, 我们可以出发具有各种测试进度信息的事件. 这里我们仅在目标方法调用前后触发事件. 感兴趣的话可以自行翻下RunNotifier中定义的其他方法</p>\n<p>接下来, 我们随便写个测试用例来用下这个<code>Runner</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.junit.Assert.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> rancho</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019-05-29</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(CustomerRunner.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerRunnerTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Calculator</span> <span class=\"variable\">calculator</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Calculator</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCalculator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start Calculator&quot;</span>);</span><br><span class=\"line\">        assertEquals(<span class=\"string\">&quot;addition&quot;</span>, <span class=\"number\">8</span>, calculator.add(<span class=\"number\">5</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Runner</code>是JUnit中的低级运行器, 相比之下, 其子类<code>ParentRunner</code>和<code>BlockJUnit4Runner</code>更加易于定制和扩展<br><code>ParentRunner</code>同样是个抽象类, 它会以分层的方式来运行测试<br>一般情况, 如果你想对Runner做定制, 从<code>BlockJUnit4Runner</code>来派生子类是不错的选择</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过定制JUnit Runner, 开发人员可以自由控制测试执行的整个过程. 一些流行的第三方Runner实现还有<code>SpringJUnit4ClassRunner</code>, <code>MockitoJUnitRunner</code>, <code>HierarchicalContextRunner</code>等<br>如果你想runwith multiple runner, 可以考虑从多个父类派生出新的子类Runner<br>而在PowerMock中, 这个问题是通过代理的方式解决的(<code>@PowerMockRunnerDelegate</code>), 也是个不错的思路</p>\n","categories":[],"tags":["编程札记","JUnit","Runner"]},{"title":"理解Python协程","url":"https://blog.ranchocooper.com/2018/12/27/understand-python-coroutine/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在Python语言的技术书籍里，关于<code>协程(Coroutine)</code>的讨论是相当匮乏的，这也导致协程成为了最鲜为人知的Python特性。到目前为止，笔者只在《Python高级编程》和《Fluent Python》两本书中见到过详细的讨论。前者是一本年代十分久远的书，不是很建议看。</p>\n<p>由于GIL的存在，导致Python多线程的性能甚至可能比单线程还要糟糕。于是就出现了协程，它由程序主动控制切换，没有切换线程的开销，因此执行效率极高。十分适用于IO密集型任务的场景；如果是CPU密集型，推荐多进程+协程的方式。</p>\n<h1 id=\"协程的演变史\"><a href=\"#协程的演变史\" class=\"headerlink\" title=\"协程的演变史\"></a>协程的演变史</h1><ul>\n<li>2006年，实现了协程的底层架构，即在Python2.5中引入yield表达式，详见<a href=\"https://www.python.org/dev/peps/pep-0342/\">PEP342</a></li>\n<li>2012年，实现了改良版的生成器句法，即在Python3.3中增加yield from语法，详见<a href=\"https://www.python.org/dev/peps/pep-0380/\">PEP380</a></li>\n<li>2016年，Python3.5中增加了<code>await</code>和<code>async</code>关键字，并且<code>asyncio</code>成为标准库一员，即简化协程的使用，详见<a href=\"https://www.python.org/dev/peps/pep-0492/\">PEP492</a></li>\n</ul>\n<p>在Python官方内置asyncio之前，只有第三方库对协程的支持，比如<code>gevent</code>和<code>Tornado</code>。而Python对协程的支持，实质是通过<code>generator</code>实现的。可以说，协程在Python中的实现，就是遵循某些规则的生成器。</p>\n<h1 id=\"生成器简介\"><a href=\"#生成器简介\" class=\"headerlink\" title=\"生成器简介\"></a>生成器简介</h1><p><a href=\"https://www.python.org/dev/peps/pep-0255/\">PEP255</a>中所定义的生成器，就是包含yield关键字的函数。当解释器执行到yield语句，就会像return语句那样返回一个值，但不同的是：此时解释器会保存对栈的引用，并在下一次通过<code>next()</code>来调用生成器时，恢复该函数栈的执行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: <span class=\"keyword\">def</span> <span class=\"title function_\">simple_generator</span>():</span><br><span class=\"line\">   ...:     <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">   ...:     <span class=\"keyword\">yield</span> <span class=\"number\">2</span></span><br><span class=\"line\">   ...:     <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;rancho&#x27;</span></span><br><span class=\"line\">   ...:</span><br><span class=\"line\">   ...:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 得到生成器对象</span></span><br><span class=\"line\">In [<span class=\"number\">2</span>]: simple_generator()</span><br><span class=\"line\">Out[<span class=\"number\">2</span>]: &lt;generator <span class=\"built_in\">object</span> simple_generator at <span class=\"number\">0x110685de0</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">3</span>]: g = simple_generator()</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">4</span>]: <span class=\"built_in\">next</span>(g)</span><br><span class=\"line\">Out[<span class=\"number\">4</span>]: <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">5</span>]: <span class=\"built_in\">next</span>(g)</span><br><span class=\"line\">Out[<span class=\"number\">5</span>]: <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">6</span>]: <span class=\"built_in\">next</span>(g)</span><br><span class=\"line\">Out[<span class=\"number\">6</span>]: <span class=\"string\">&#x27;rancho&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次唤醒, 生成器会抛出StopIteration异常</span></span><br><span class=\"line\">In [<span class=\"number\">7</span>]: <span class=\"built_in\">next</span>(g)</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">StopIteration                             Traceback (most recent call last)</span><br><span class=\"line\">&lt;ipython-<span class=\"built_in\">input</span>-<span class=\"number\">7</span>-e734f8aca5ac&gt; <span class=\"keyword\">in</span> &lt;module&gt;()</span><br><span class=\"line\">----&gt; <span class=\"number\">1</span> <span class=\"built_in\">next</span>(g)</span><br><span class=\"line\"></span><br><span class=\"line\">StopIteration:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">8</span>]:</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>inspect.isgeneratorfunction</code>，可以检查一个函数是否是生成器。阅读其源码，也可以洞察生成器函数标识的内部实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">isgeneratorfunction</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return true if the object is a user-defined generator function.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Generator function objects provide the same attributes as functions.</span></span><br><span class=\"line\"><span class=\"string\">    See help(isfunction) for a list of attributes.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">bool</span>((isfunction(<span class=\"built_in\">object</span>) <span class=\"keyword\">or</span> ismethod(<span class=\"built_in\">object</span>)) <span class=\"keyword\">and</span></span><br><span class=\"line\">                <span class=\"built_in\">object</span>.__code__.co_flags &amp; CO_GENERATOR)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>另外，生成器还被定义了四种状态，它们分别是<code>GEN_CREATED</code>(创建但未激活), <code>GEN_RUNNING</code>(正被解析器执行), <code>GEN_SUSPENDED</code>(等待调用方唤醒), 以及<code>GEN_CLOSED</code>(已经结束运行).</p>\n<h1 id=\"生成器的进化\"><a href=\"#生成器的进化\" class=\"headerlink\" title=\"生成器的进化\"></a>生成器的进化</h1><p>基于PEP255所定义的生成器, PEP342对其做了改良: 在生成器API中增加了<code>send()</code>, <code>throw()</code>以及<code>close()</code>方法。</p>\n<p>至此，调用方可以通过<code>send()</code>方法向生成器发送数据，并且发送的数据会成为生成器函数中yield表达式的值。这是生成器向协程进化的关键一步，这样一来，生成器可以与调用方协作，产出由调用方提供的值。而throw和close方法，前者的作用是让调用方抛出异常；后者是让调用发直接终止生成器。</p>\n<p>协程的简单使用演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">8</span>]: <span class=\"keyword\">def</span> <span class=\"title function_\">simple_coroutine</span>():</span><br><span class=\"line\">   ...:     <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;-&gt; coroutine started&#x27;</span>)</span><br><span class=\"line\">   ...:     x = <span class=\"keyword\">yield</span></span><br><span class=\"line\">   ...:     <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;-&gt; coroutine received x: &#x27;</span>, x)</span><br><span class=\"line\">   ...:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同创建生成器的方式, 调用函数得到生成器对象</span></span><br><span class=\"line\">In [<span class=\"number\">9</span>]: c = simple_coroutine()</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">10</span>]: c</span><br><span class=\"line\">Out[<span class=\"number\">10</span>]: &lt;generator <span class=\"built_in\">object</span> simple_coroutine at <span class=\"number\">0x1106852a0</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活生成器, 此时解释器会停留在第一个yield语句, 并等待调用方传值</span></span><br><span class=\"line\">In [<span class=\"number\">11</span>]: <span class=\"built_in\">next</span>(c)</span><br><span class=\"line\">-&gt; coroutine started</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过send传值, 此时协程会被唤醒, 协程函数栈继续执行, 直到碰到下一个yield表达式, 或者执行到协程定义体尾部, 抛出异常</span></span><br><span class=\"line\">In [<span class=\"number\">12</span>]: c.send(<span class=\"number\">666</span>)</span><br><span class=\"line\">-&gt; coroutine received x:  <span class=\"number\">666</span></span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">StopIteration                             Traceback (most recent call last)</span><br><span class=\"line\">&lt;ipython-<span class=\"built_in\">input</span>-<span class=\"number\">12</span>-21bbe31479b2&gt; <span class=\"keyword\">in</span> &lt;module&gt;()</span><br><span class=\"line\">----&gt; <span class=\"number\">1</span> c.send(<span class=\"number\">666</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">StopIteration:</span><br></pre></td></tr></table></figure>\n\n<p>同样的, 协程也有生成器的四种状态. 因为send方法的参数会成为暂停的yield表达式的值, 所以, 仅当协程处于暂停状态时, 才能调用send方法. 比如, 如果协程才被创建, 尚未激活, 便会抛错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">14</span>]: sleep = simple_coroutine()</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">15</span>]: sleep.send(<span class=\"number\">2019</span>)</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">TypeError                                 Traceback (most recent call last)</span><br><span class=\"line\">&lt;ipython-<span class=\"built_in\">input</span>-<span class=\"number\">15</span>-b30e05632a4d&gt; <span class=\"keyword\">in</span> &lt;module&gt;()</span><br><span class=\"line\">----&gt; <span class=\"number\">1</span> sleep.send(<span class=\"number\">2019</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">TypeError: can<span class=\"string\">&#x27;t send non-None value to a just-started generator</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你有兴趣仔细探究协程各个时期的状态, 可以结合<code>inspect.getgeneratorstate</code>方法, 自行探究理解协程的行为</p>\n<h2 id=\"预激协程\"><a href=\"#预激协程\" class=\"headerlink\" title=\"预激协程\"></a>预激协程</h2><p>首次调用next()函数, 这一步被称为<code>预激(prime)</code>协程. 我们可以简单地通过装饰器来实现预激</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">coroutine</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\"><span class=\"meta\">    @wraps(<span class=\"params\">func</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">primer</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        gen = func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"built_in\">next</span>(gen)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gen</span><br><span class=\"line\">    <span class=\"keyword\">return</span> primer</span><br></pre></td></tr></table></figure>\n<p>其实很多框架都提供了处理协程的特殊装饰器, 比如Tornado提供了<code>tornado.gen</code>, 它除了预激协程, 还会勾入事件循环. 值得注意的是, <code>yield from</code>句法本身就会自动预激, 因此和示例中的装饰器并不兼容. 而Python3.4标准库中的<code>asyncio.coroutine</code>装饰器不会预激协程, 因此兼容<code>yield from</code></p>\n<h2 id=\"终止协程\"><a href=\"#终止协程\" class=\"headerlink\" title=\"终止协程\"></a>终止协程</h2><p>因为协程的运作受调用方控制, 因此可以通过发送某个哨符值, 让协程退出. 内置的<code>None</code>和<code>Ellipsis</code>等常量就是不错的选择<br>另外, 底层的生成器API —- close方法会让生成器在暂停的yield表达式处抛出<code>GeneratorExit</code>异常</p>\n<pre><code>generator.close()\n</code></pre>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>前面提到, PEP255中, 为生成器添加了<code>throw</code>方法</p>\n<pre><code>generator.throw(exc_type[, exc_value[, traceback]])\n</code></pre>\n<p>如果生成器处理了抛出的异常, 代码就会继续执行到下一个yield表达式, 而产出的值就变变成调用<code>generator.throw</code>方法得到的返回值. 如果生成器没有处理抛出的异常, 异常就会向上冒泡, 传到调用方的上下文中</p>\n<h2 id=\"让协程返回值\"><a href=\"#让协程返回值\" class=\"headerlink\" title=\"让协程返回值\"></a>让协程返回值</h2><p>在Python3.3之前, 如果生成器返回值, 解释器就会报错. 按照PEP380中定义的方式, 获取协程的返回值需要绕个圈子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用前面定义的预计装饰器</span></span><br><span class=\"line\">In [<span class=\"number\">19</span>]: @coroutine</span><br><span class=\"line\">    ...: <span class=\"keyword\">def</span> <span class=\"title function_\">simple_demo</span>():</span><br><span class=\"line\">    ...:     <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    ...:         x = <span class=\"keyword\">yield</span></span><br><span class=\"line\">    ...:         <span class=\"keyword\">if</span> x <span class=\"keyword\">is</span> <span class=\"literal\">Ellipsis</span>:</span><br><span class=\"line\">    ...:             <span class=\"keyword\">break</span></span><br><span class=\"line\">    ...:         <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;receive x: &#x27;</span>, x)</span><br><span class=\"line\">    ...:     <span class=\"keyword\">return</span> <span class=\"string\">&#x27;customer return value&#x27;</span></span><br><span class=\"line\">    ...:</span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">20</span>]: c = simple_demo()</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">21</span>]: c.send(<span class=\"number\">3</span>)</span><br><span class=\"line\">receive x:  <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">22</span>]: c.send(<span class=\"literal\">Ellipsis</span>)</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">StopIteration                             Traceback (most recent call last)</span><br><span class=\"line\">&lt;ipython-<span class=\"built_in\">input</span>-<span class=\"number\">22</span>-70d622b4e36a&gt; <span class=\"keyword\">in</span> &lt;module&gt;()</span><br><span class=\"line\">----&gt; <span class=\"number\">1</span> c.send(<span class=\"literal\">Ellipsis</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">StopIteration: customer <span class=\"keyword\">return</span> value</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">24</span>]: <span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ...:     c.send(<span class=\"literal\">Ellipsis</span>)</span><br><span class=\"line\">    ...: <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> exc:</span><br><span class=\"line\">    ...:     result = exc.value</span><br><span class=\"line\">    ...:     <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;got result: &#x27;</span>, result)</span><br><span class=\"line\">    ...:</span><br><span class=\"line\">got result:  <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>不难发现, 当协程返回某个值时, 同样会抛出StopIteration异常, 并且异常的值就是协程返回的值. 对于<code>yield from</code>句法来说, 解释器不仅会捕获<code>StopIteration</code>异常, 还会把value属性的值变成yield from表达式的值</p>\n<h1 id=\"yield-from-句法\"><a href=\"#yield-from-句法\" class=\"headerlink\" title=\"yield from 句法\"></a>yield from 句法</h1><p><code>yield from</code> 是全薪的语言结构, 它的作用比yield关键字多很多.</p>\n<h2 id=\"专用术语\"><a href=\"#专用术语\" class=\"headerlink\" title=\"专用术语\"></a>专用术语</h2><ul>\n<li>调用方: 调用委派生成器的客户端代码</li>\n<li>委派生成器: 包含<code>yield from &lt;iterable&gt;</code>表达式的生成器函数</li>\n<li>子生成器: 委派生成器中所获取的生成器, 也就是PEP380标题中所指的<code>subgenerator</code></li>\n</ul>\n<p><img src=\"/professional-term.png\" alt=\"术语图解\"></p>\n<h2 id=\"简单示范\"><a href=\"#简单示范\" class=\"headerlink\" title=\"简单示范\"></a>简单示范</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">25</span>]: <span class=\"keyword\">def</span> <span class=\"title function_\">gen</span>():</span><br><span class=\"line\">    ...:     <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"string\">&#x27;rancho&#x27;</span>:</span><br><span class=\"line\">    ...:         <span class=\"keyword\">yield</span> c</span><br><span class=\"line\">    ...:     <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">    ...:         <span class=\"keyword\">yield</span> i</span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">26</span>]: <span class=\"built_in\">list</span>(gen())</span><br><span class=\"line\">Out[<span class=\"number\">26</span>]: [<span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yield from结构改写</span></span><br><span class=\"line\">In [<span class=\"number\">27</span>]: <span class=\"keyword\">def</span> <span class=\"title function_\">gen</span>():</span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rancho&#x27;</span></span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">28</span>]: <span class=\"built_in\">list</span>(gen())</span><br><span class=\"line\">Out[<span class=\"number\">28</span>]: [<span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p14_flattening_nested_sequence.html\">Cook Book - 展开嵌套的序列</a>有个稍复杂的参考示例.<br>可能是yield from句法太过便捷, 以至于有人在<a href=\"https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3\">StackOverFlow</a>上对该语法特性的用处发出了灵魂质问<br>实际上除了职责委派之外, yield from会在调用方和子生成器之间打开双向通道, 这样二者就可以直接发送和产出值, 并且可以直接传入异常, 而不需要位于中间的委派生成器中添加大量样板代码</p>\n<p>在PEP380中，生成器句法被加以改动，其<a href=\"https://www.python.org/dev/peps/pep-0380/#proposal\">proposal</a>一节, 对<code>yield from</code>做了六点阐述</p>\n<ul>\n<li>子生成器传出的值, 都直接传给委派生成器的调用方 (即客户端代码)</li>\n<li>调用方通过<code>send()</code>方法传入的值, 都会直接传给子生成器. 如果发送的是<code>None</code>, 则调用子生成器的<code>__next__()</code>方法, 否则通过调用子生成器的<code>send()</code>方法, 向下传递. 如果子生成器抛出<code>StopIteration</code>异常, 那么委派生产器恢复运行, 如果子生成器抛出其他异常, 都会向上冒泡, 传递给委派生成器</li>\n<li>当生成器退出时, 生成器(或者说子生成器)中的<code>return expr</code> 表达式会触发<code>StopIteration(expr)</code>异常并抛出</li>\n<li><code>yield from</code> 表达式的值是子生成器终止时传给<code>StopIteration</code>异常的第一个参数</li>\n</ul>\n<p>另外提及的两点特性, 与异常和终止有关</p>\n<ul>\n<li>传给委派生成器的异常, 除了<code>GeneratorExit</code>之外都会下发给子生成器的<code>throw()</code>方法. 如果调用<code>throw()</code>方法时抛出<code>StopIteration</code>, 委派生成器恢复运行, 若抛出其他异常, 都会冒泡给委派生成器</li>\n<li>如果把<code>GeneratorExit</code>异常传入委派生成器, 或者调用<code>close()</code>方法, 则会在子生成器上调用<code>close()</code>方法. 如果调用<code>close()</code>导致异常抛出, 那么异常会冒泡, 否则, 委派生成器抛出<code>GeneratorExit</code>异常.</li>\n</ul>\n<p><code>yield from</code>的语义比较难简洁地阐述出来, PEP380中附加了一段<a href=\"https://www.python.org/dev/peps/pep-0380/#formal-semantics\">伪代码</a>来演示<code>yield from </code>的行为<br>下面对其做简化, 以描述<code>yield from</code>的运作方式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 假设解释器碰到下面这行yield from句法</span></span><br><span class=\"line\">RESULT = <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> EXPR</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 那么内部的处理逻辑如下</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># EXPR是可迭代对象, 获取其迭代器</span></span><br><span class=\"line\">_i = <span class=\"built_in\">iter</span>(EXPR)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 预激子生成器</span></span><br><span class=\"line\">    _y = <span class=\"built_in\">next</span>(_i)</span><br><span class=\"line\"><span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> _e:</span><br><span class=\"line\">    _r = _e.value</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 运行这个循环时, 委派生成器会阻塞, 只作为调用方和子生成器间的通道</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 产出子生成器的值, 并等待调用方唤醒</span></span><br><span class=\"line\">        _s = <span class=\"keyword\">yield</span> _y</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 下发调用方的传入值给子生成器</span></span><br><span class=\"line\">            _y = _i.send(_s)</span><br><span class=\"line\">        <span class=\"comment\"># 如果子生成器终止, 获取异常的value属性, 退出循环, 并唤醒委派生成器</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> _e:</span><br><span class=\"line\">            _r = _e.value</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">RESULT = _r</span><br></pre></td></tr></table></figure>\n\n<p>这段简化后的代码不支持<code>throw()</code>和<code>close()</code>方法, 也没有处理传入<code>None</code>的情形, 如果想知道应对实际情况下的实现, 建议查看上面PEP的完整伪代码</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Guido大叔说生成器有三种代码编写风格: 拉取式(迭代器), 推送式(send), 以及任务式(<a href=\"http://www.dabeaz.com/coroutines/\">详见</a>).<br>不过在实际应用中, 感觉多数项目都是采用<code>yield from</code>来驱动协程, 而不通过直接在协程上调用<code>send()</code>方法驱动, 这一切都得益于<code>asyncio</code>库的底层处理了<code>next()</code>和<code>send()</code>方法驱动, 用户代码只需使用<code>yield from</code>句法, 便可驱动协程运行</p>\n<p>实际上自Python3.5, 提供了async&#x2F;await关键字后, 基本取代了send + yield from的结构.<br>不过弄明白协程以及<code>yield from</code>句法, 新引入的关键字就很好理解了, 只是简化语法, 隐藏细节</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li>《Fluent Python》 * 主推</li>\n<li>《Python高级编程》</li>\n<li>《Python高手之路》</li>\n</ul>\n","categories":[],"tags":["编程札记","Python","协程"]},{"title":"深入Java注解","url":"https://blog.ranchocooper.com/2018/11/08/drive-into-java-annotation/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p>近日暂别热爱且把玩多年的Python, 转向Java阵营. 转型期间遇到的首个confusion便是注解, 一方面是它长得很像Python装饰器, 另一方面是搬砖仿写时出镜率贼高, 但又特别陌生.</p>\n<h2 id=\"注解的本质\"><a href=\"#注解的本质\" class=\"headerlink\" title=\"注解的本质\"></a>注解的本质</h2><p><code>java.lang.annotation.Annotation</code>有这么句话, 用于描述『注解』</p>\n<blockquote>\n<p>The Common interface extended by all annotation types.<br>所有的注解类型都继承自本接口.</p>\n</blockquote>\n<p>虽然抽象但言简意赅, 再来看看常见的<code>Override</code> 注解的JDK源码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它本质上其实就是继承了<code>Annatation</code>接口的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Override</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Annotation</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个注解准确意义上讲, 只是一种特殊的注释而已, 如果没有解析它的代码, 可能连注释都不如. 而解析一个类或者方法的注解往往有两种方式, 一种是编译期间的直接扫描, 一种是运行时反射. 反射的事情后面再说, 而编译期间的扫描, 指的是编译器在将Java代码编译成字节码的过程中, 如果检测到了某个类或者方法被注释所修饰, 这时编译器就会对这些注解进行特定处理.</p>\n<p><code>@Override</code>就是个典型的例子, 一旦编译器发现了它, 就会检查当前方式签名是否真的重写了父类中的方法, 也就是看父类中是否有同样的方法签名.</p>\n<p>这种情况只适用于那些编译器熟知的注解类, 编译器厂商并不会为个人定制的注解提供服务, 当然他们也不知道该如何处理你的注解, 往往只是根据该注解的作用范围, 来选择是否编译进字节码文件里, 仅此而已.</p>\n<h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><p><code>元注解</code>就是用于修饰注解的注解, 在<code>@Override</code>的定义中, <code>@Target</code>, <code>@Retention</code>就是所谓的『元注解』. 它一般用于指定某个注解的生命周期以及作用目标等信息.</p>\n<p>Java中有以下几种『元注解』</p>\n<ul>\n<li>@Target: 注解的作用目标</li>\n<li>@Retention: 注解的声明周期</li>\n<li>@Documented: 注解是否被包含在JavaDoc文档中</li>\n<li>@Inherited: 注解是否被子类所继承</li>\n</ul>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h3><p><code>@Target</code>用于指明被修饰的注解可以作用的目标, 是用来修饰一个方法, 一个类? 还是仅用于修饰字段属性的</p>\n<p><code>@Target</code>的定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Target &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class=\"line\"><span class=\"comment\">     * can be applied to.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class=\"line\"><span class=\"comment\">     * can be applied to</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ElementType[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TODO. 不明白怎么不会出现循环定义的问题</p>\n<p>我们可以通过以下方式来给注解传值</p>\n<pre><code>@Target(value=&#123;ElementType.FIELED&#125;)\n</code></pre>\n<p>其中, ElementType是个枚举类型, 它的值有</p>\n<ul>\n<li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li>\n<li>ElementType.FIELD：允许作用在属性字段上</li>\n<li>ElementType.METHOD：允许作用在方法上</li>\n<li>ElementType.PARAMETER：允许作用在方法参数上</li>\n<li>ElementType.CONSTRUCTOR：允许作用在构造器上</li>\n<li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li>\n<li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li>\n<li>ElementType.PACKAGE：允许作用在包上</li>\n</ul>\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"Retention\"></a>Retention</h3><p><code>@Retention</code>用于指明当前注解的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Retention &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the retention policy.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the retention policy</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    RetentionPolicy <span class=\"title function_\">value</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的, 这里的RetentionPolicy也是个枚举类型, 它的值有</p>\n<ul>\n<li>RetentionPolicy.SOURCE：注解仅在编译期可见，不会写入 class 文件</li>\n<li>RetentionPolicy.CLASS：注解在类加载阶段丢弃，会写入 class 文件</li>\n<li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li>\n</ul>\n<p><code>@Document</code>和<code>@inherited</code>比较简单, 就不细说. 前者在我们执行JavaDoc文档打包时会被保存进doc文档, 后者表示该注解是可以被继承的, 即该类的子类将自动继承父类的该注解.</p>\n<h2 id=\"Java三大内置注解\"><a href=\"#Java三大内置注解\" class=\"headerlink\" title=\"Java三大内置注解\"></a>Java三大内置注解</h2><p>除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是</p>\n<ul>\n<li>@Override</li>\n<li>@Deprecated</li>\n<li>@SuppressWarnings</li>\n</ul>\n<h3 id=\"Override\"><a href=\"#Override\" class=\"headerlink\" title=\"Override\"></a>Override</h3><p><code>@Override</code>前面已经提到, 定义如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们知道, 该注解仅对方法起作用, 而且在编译结束即被丢弃. 所以, <code>@Override</code>是一种典型的『标记式注解』, 仅被编译器感知.</p>\n<h3 id=\"Deprecated\"><a href=\"#Deprecated\" class=\"headerlink\" title=\"Deprecated\"></a>Deprecated</h3><p><code>@Deprecated</code>的基本定义如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Deprecated &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>依然是一种『标记式注解』, 永久存在, 而且可以修饰所有类型. 作用是标记当前的类或方法或字段等已经不再被推荐使用</p>\n<p>当然编译器并不会强制你做什么修改</p>\n<h3 id=\"SuppressWarnings\"><a href=\"#SuppressWarnings\" class=\"headerlink\" title=\"SuppressWarnings\"></a>SuppressWarnings</h3><p><code>@SuppressWarnings</code>主要用来压制Java警告, 其定义是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SuppressWarnings &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class=\"line\"><span class=\"comment\">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class=\"line\"><span class=\"comment\">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class=\"line\"><span class=\"comment\">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class=\"line\"><span class=\"comment\">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class=\"line\"><span class=\"comment\">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class=\"line\"><span class=\"comment\">     * warning name.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt; The string &#123;<span class=\"doctag\">@code</span> &quot;unchecked&quot;&#125; is used to suppress</span></span><br><span class=\"line\"><span class=\"comment\">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class=\"line\"><span class=\"comment\">     * additional warning names they support in conjunction with this</span></span><br><span class=\"line\"><span class=\"comment\">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class=\"line\"><span class=\"comment\">     * that the same names work across multiple compilers.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the set of warnings to be suppressed</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String[] value();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它有一个value属性需要在使用时主动传值, 然后编译器就会跳过对应类型的警告</p>\n<p>(其实后两个感觉不常用, 怎么就上榜了三大内置注解呢?)</p>\n<h2 id=\"注解与反射\"><a href=\"#注解与反射\" class=\"headerlink\" title=\"注解与反射\"></a>注解与反射</h2><p>上述内容简单理清了注解的定义和使用方式, 现在我们从虚拟机的层面看看, 注解的本质到底是什么</p>\n<p>首先, 我们自定义一个注解类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>: Rancho Cooper</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span> 2018/11/9</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Desc</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target(value= &#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Comment &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们让<code>Comment</code>注解只能修饰字段和方法, 并且注解一直存活, 以便在运行时反射获取</p>\n<p>前面我们说, 虚拟机(编译器实现)规范定义了一系列和注解相关的属性表, 无论是字段, 方法或是类本身, 如果被注解修饰了, 就会被写入字节码文件里. 属性表有以下几种</p>\n<ul>\n<li>RuntimeVisibleAnnotations：运行时可见的注解</li>\n<li>RuntimeInVisibleAnnotations：运行时不可见的注解</li>\n<li>RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解</li>\n<li>RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解</li>\n<li>AnnotationDefault：注解类元素的默认值</li>\n</ul>\n<p>而对于一个类或者接口来说, Class类中提供了以下方法用于反射注解</p>\n<ul>\n<li>getAnnotation：返回指定的注解</li>\n<li>isAnnotationPresent：判定当前元素是否被指定注解修饰</li>\n<li>getAnnotations：返回所有的注解</li>\n<li>getDeclaredAnnotation：返回本元素的指定注解</li>\n<li>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</li>\n</ul>\n<p>方法, 字段中相关的反射注解的方式基本类似. 我们来实际操作一下. 首先, 随便写个Main, 并使用上面的Comment注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Comment(&quot;hello&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> Main.class;</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> cls.getMethod(<span class=\"string\">&quot;main&quot;</span>, String[].class);</span><br><span class=\"line\">        <span class=\"type\">Comment</span> <span class=\"variable\">hello</span> <span class=\"operator\">=</span> method.getAnnotation(Comment.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后设置虚拟机启动参数, 用于捕获JDK动态代理类</p>\n<pre><code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true\n</code></pre>\n<p>运行程序后, 项目下就会多出输出目录, 打开<code>com/sun/proxy</code>下的文件, 便可以看到虚拟机动态代理机制生成的代理类<br>(idea中双击打开直接能看到反编译后的代码, 不需额外折腾反编译工具)</p>\n<p>不难发现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">$Proxy1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Comment</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ommit some insignificant source code</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m4;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy1(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (String)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m3, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Class <span class=\"title function_\">annotationType</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Class)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m4, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            m1 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;equals&quot;</span>, Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>));</span><br><span class=\"line\">            m2 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;toString&quot;</span>);</span><br><span class=\"line\">            m4 = Class.forName(<span class=\"string\">&quot;Comment&quot;</span>).getMethod(<span class=\"string\">&quot;annotationType&quot;</span>);</span><br><span class=\"line\">            m0 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;hashCode&quot;</span>);</span><br><span class=\"line\">            m3 = Class.forName(<span class=\"string\">&quot;Comment&quot;</span>).getMethod(<span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchMethodError</span>(var2.getMessage());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在得到的代理类中, 实现了接口Comment, 并重写了所有方法, 包括<code>value</code>方法以及从<code>Annotation</code>继承而来的方法</p>\n<p>而且这个代理类中有个构造函数, 它接受<code>InvocationHandler</code>. AnnotationInvocationHandler是Java中专门用于处理注解的Handler. 源码见<a href=\"https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java\">这里</a>(费了不少功夫才找到… )</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AnnotationInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span>, Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">6182022883658399397L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Annotation</span>&gt; type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class=\"line\"></span><br><span class=\"line\">    AnnotationInvocationHandler(Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class=\"line\">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!type.isAnnotation() ||</span><br><span class=\"line\">            superInterfaces.length != <span class=\"number\">1</span> ||</span><br><span class=\"line\">            superInterfaces[<span class=\"number\">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationFormatError</span>(<span class=\"string\">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.memberValues = memberValues;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其构造参数接受<code>memberValues</code>, 它是个键值对, 键是我们注解的属性名称, 值是其被定义时赋的值. 再往下是一个<code>invoke</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">member</span> <span class=\"operator\">=</span> method.getName();</span><br><span class=\"line\">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle Object and Annotation methods</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (member.equals(<span class=\"string\">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">        paramTypes[<span class=\"number\">0</span>] == Object.class)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> equalsImpl(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (paramTypes.length != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>(<span class=\"string\">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(member) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;toString&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> toStringImpl();</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;hashCode&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hashCodeImpl();</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;annotationType&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle annotation member accessors</span></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> memberValues.get(member);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IncompleteAnnotationException</span>(type, member);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result <span class=\"keyword\">instanceof</span> ExceptionProxy)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        result = cloneArray(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面的动态代理类代理了注解接口中所有的方法, 实际上代理类中任何方法的调用, 最终都会被转到这里来. <code>invoke</code>的入参之一是被调用的方法实例, 首先会拿到方法实例的名字, 如果被调用的是<code>equals</code>走了特殊流程(emmm, 没看明白), 如果是toString, hashCode, annotationType的话, 会直接返回AnnotationInvocationHandler 预定义的方法实现.</p>\n<p>而如果没有匹配到以上四种方法, 说明当前的方法调用是自定义注解字节声明的方法, 例如我们<code>Comment</code>注解的value方法. 这种情况下, 将从我们的注解map中获取注解属性对应的值</p>\n<p>总的来讲, 当我们通过键值对的形式来给注解赋值时, 比如<code>@Comment(value=&quot;doc it&quot;)</code>, 并用注解修饰某元素. 那么编译器将在编译期间扫描作用对象(类或方法等)上的注解, 然后做基本检查, 如果注解允许被作用在当前位置(元注解的作用), 则将注解信息写入该元素的属性表</p>\n<p>然后, 当你在运行时进行反射时, 虚拟机会将所有生命周期在<code>RUNTIME</code>的注解取出, 存入一个map, 并传递给一个<code>AnnotationInvocationHandler</code>实例.</p>\n<p>最后, 虚拟机将采用JDK动态代理机制生成一个目标注解的代理类, 并初始化好处理器</p>\n<p>这样, 一个注解的实例就创建出来了. 它本质上是个代理类</p>\n","categories":[],"tags":["编程札记","Java","注解"]},{"title":"Python3.7新特性概览","url":"https://blog.ranchocooper.com/2018/06/29/whats-new-in-python-3-7/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p>Python官方于6.27发布了V3.7.0的更新说明，包含很多新特性和优化。<br>另外值得注意的是，此次更新<strong>不完全向后兼容</strong>。</p>\n<p><a href=\"https://docs.python.org/3/whatsnew/3.7.html\">官方文档</a></p>\n<h2 id=\"主要亮点\"><a href=\"#主要亮点\" class=\"headerlink\" title=\"主要亮点\"></a>主要亮点</h2><ul>\n<li><p>新语法特性：</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/whatsnew/3.7.html#whatsnew37-pep563\">PEP 563</a>延迟加载类型注解，依赖<code>from __future__ import annotations</code>·</li>\n</ul>\n</li>\n<li><p>向后不兼容的语法更改：</p>\n<ul>\n<li><code>async</code> 和 <code>await</code> 现在是保留关键字，可能部分三方库会受到影响。</li>\n</ul>\n</li>\n<li><p>新的库模块：</p>\n<ul>\n<li>contextvars: PEP 567 – Context Variables</li>\n<li>dataclasses: PEP 557 – Data Classes</li>\n<li>importlib.resources</li>\n</ul>\n</li>\n<li><p>新的built-in特性</p>\n<ul>\n<li><a href=\"https://www.python.org/dev/peps/pep-0553/\">PEP 553</a>, 添加新的内置函数 <code>breakpoint()</code>，免去了以往使用<code>pdb</code>手动设置断点的麻烦。</li>\n</ul>\n</li>\n<li><p>Python数据模型改进</p>\n<ul>\n<li><a href=\"https://www.python.org/dev/peps/pep-0562/\">PEP 562</a>, 通过定义<code>__getattr__</code>和<code>__dir__</code>属性，来定制访问模块访问。</li>\n<li><a href=\"https://www.python.org/dev/peps/pep-0560/\">PEP 560</a>, core support for typing module and generic types.</li>\n<li>保留字典的插入顺序已成为官方语言的规范。</li>\n</ul>\n</li>\n<li><p>标准库中的重要改进</p>\n<ul>\n<li><code>asyncio</code> 模块添加了新特性，并做了性能优化。</li>\n<li><code>time</code> 模块做到纳秒级别的支持。</li>\n</ul>\n</li>\n<li><p>CPython 实现的改进</p>\n<ul>\n<li>取消 ASCII 作为默认文本编码(强制<code>UTF-8</code> 的运行时编码环境)<ul>\n<li>PEP 538, legacy C locale coercion</li>\n<li>PEP 540, forced UTF-8 runtime mode</li>\n</ul>\n</li>\n<li>PEP 552, deterministic .pycs</li>\n<li>the new development runtime mode</li>\n<li>PEP 565, 优化<code>DeprecationWarning</code> 处理方式。交互环境或脚本执行方式会直接出发警告，而在框架或库导入时，则会静默处理这些警告。另外提供了三种警告行为供开发者使用：<code>FutureWarning</code>, <code>DeprecationWarning</code>, <code>PendingDeprecationWarning</code></li>\n</ul>\n</li>\n<li><p>C API改进</p>\n<ul>\n<li>PEP 539, new C API for thread-local storage</li>\n</ul>\n</li>\n<li><p>文档改进</p>\n<ul>\n<li>Python官方文档新增日韩法三种语言版本</li>\n</ul>\n</li>\n</ul>\n<p>另外，3.7版本也着重对性能做了优化，更多细节可见<a href=\"https://docs.python.org/3/whatsnew/3.7.html#whatsnew37-perf\">Optimizations</a></p>\n<h2 id=\"特性详解\"><a href=\"#特性详解\" class=\"headerlink\" title=\"特性详解\"></a>特性详解</h2><h3 id=\"延迟加载类型注释\"><a href=\"#延迟加载类型注释\" class=\"headerlink\" title=\"延迟加载类型注释\"></a>延迟加载类型注释</h3><p>类型注解是Python3.x中引入的新特性，但目前的类型注解特性存在两个明显的可用性问题：</p>\n<ul>\n<li>类型注解只能使用当前作用域内的已有类型，换言之，它不支持类型的前向引用。</li>\n<li>类型注释的实现方式影响了Python的启动时间。</li>\n</ul>\n<p>通过延迟加载类型注释，可以完美解决这两个问题。编译器不是在类型注解的定义处马上编译并执行代码，而是将注解以字符串的形式存储起来(可以理解为是存在表达式对应的AST结构中)。在需要时，可以通过<code>typing.get_type_hints()</code> 在运行时解析注解。由于通常注解都不是运行时所需，所以这种方案通过廉价的存储开销换来启动速度的提升。</p>\n<p>当然，延迟加载最直观的体现是在下面这种情况</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> typing</span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> annotations</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Relation</span>:</span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">contact</span>(<span class=\"params\">cls, someone: People, anotherone: People</span>) -&gt; Relation:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(Relation.contact.__annotations__)             <span class=\"comment\"># it works though haven&#x27;t define `People`</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(typing.get_type_hints(Relation.contact))      <span class=\"comment\"># trigger error cause evaluate type hint at runtime</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">People</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(typing.get_type_hints(Relation.contact))      <span class=\"comment\"># it works too</span></span><br></pre></td></tr></table></figure>\n\n<p>在实际使用时需要通过<code>__future__</code> 手动导入延迟加载特性，未来在Python4.0中将会是默认行为。</p>\n<h3 id=\"内置breakpoint\"><a href=\"#内置breakpoint\" class=\"headerlink\" title=\"内置breakpoint()\"></a>内置breakpoint()</h3><p>内置的<code>breakpoint()</code> 会调用<code>sys.brewkpointhook()</code>。<br>默认情况下后者会导入<code>pdb</code> 然后调用<code>pdb.set_trace()</code>。通过重新绑定<code>sys.breakpointhook</code>，你也可以定制使用其他调试器。实际上绑到任何<code>callable</code> 对象都是可以的。另外，也可以通过配置<code>PYTHONBREAKPOINT</code> 环境变量来设定调试器，当将其设为<code>0</code> 则表示禁用内置的<code>breakpoint()</code></p>\n<h3 id=\"定制访问模块属性\"><a href=\"#定制访问模块属性\" class=\"headerlink\" title=\"定制访问模块属性\"></a>定制访问模块属性</h3><p>在模块级别上支持定义<code>__getattr__()</code>与<code>__dir__()</code>，用武之地的可能就是模块属性的弃用警告和延迟加载。</p>\n<ul>\n<li>模块或库升级的弃用警告</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> warnings</span><br><span class=\"line\"></span><br><span class=\"line\">warnings.filterwarnings(<span class=\"string\">&#x27;default&#x27;</span>)  <span class=\"comment\"># Python3.2开始会默认隐藏DeprecationWarning</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">new_function</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;[actually] using new function&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">deprecated_map = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;old_function&#x27;</span>: new_function</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__getattr__</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> name <span class=\"keyword\">in</span> deprecated_map:</span><br><span class=\"line\">        switch_to = deprecated_map[name]</span><br><span class=\"line\">        warnings.warn(<span class=\"string\">f&quot;<span class=\"subst\">&#123;name&#125;</span> is deprecated. Switch to <span class=\"subst\">&#123;__name__&#125;</span>.<span class=\"subst\">&#123;switch_to.__name__&#125;</span>&quot;</span>, DeprecationWarning)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> switch_to</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">f&quot;module <span class=\"subst\">&#123;__name__&#125;</span> has no attribute <span class=\"subst\">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from lib import old_function</span><br><span class=\"line\">/Users/rancho/blog/lib.py:22: DeprecationWarning: old_function is deprecated. Switch to lib.new_function</span><br><span class=\"line\">&gt;&gt;&gt; old_function</span><br><span class=\"line\">&lt;<span class=\"keyword\">function</span> lib.new_function(*args, **args)&gt;</span><br><span class=\"line\">&gt;&gt;&gt; old_function(1)</span><br><span class=\"line\">[actually] using new <span class=\"keyword\">function</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>惰性加载</li>\n</ul>\n<blockquote>\n<p>惰性加载有点像linux内核中的写时拷贝。写时拷贝是当fork出的进程发生了数据变更时，才从父进程拷贝数据。类似的，惰性加载就是当导入的对象实际发生调用时才会将其加载到当前内存空间中。这种做法可以避免因过早地导入过大的数据对象但实际上尚未使用而导致的空间浪费。简言之，就是从立即导入变成了用时导入。</p>\n</blockquote>\n<p>按照以往的模块导入方式，必须要等模块里的相关属性&#x2F;函数&#x2F;类都准备妥当了，才完成模块导入的工作。惰性加载在模块导入阶段能大大提升效率</p>\n<p>PEP中演示的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># lib/__init__.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> importlib</span><br><span class=\"line\"></span><br><span class=\"line\">__all__ = [<span class=\"string\">&#x27;submod&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__getattr__</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> name <span class=\"keyword\">in</span> __all__:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> importlib.import_module(<span class=\"string\">&quot;.&quot;</span> + name, __name__)</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">f&quot;module <span class=\"subst\">&#123;__name__!r&#125;</span> has no attribute <span class=\"subst\">&#123;name!r&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># lib/submod.py</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;submodule loaded&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># main.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> lib</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">trigger</span>():</span><br><span class=\"line\">    lib.submod.A</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，只有当main.trigger执行时，才会输出<code>submodule loaded</code></p>\n<h3 id=\"弃用警告的展示\"><a href=\"#弃用警告的展示\" class=\"headerlink\" title=\"弃用警告的展示\"></a>弃用警告的展示</h3><p>自Python3.2起，默认不显示弃用警告。此次更新中，当触发它们的代码直接在<code>__main__</code> 模块中运行便会显示。默认情况下，导入应用程序，库和框架时若触发弃用警告，仍然会被隐藏。</p>\n<p>另外，标准库现在允许开发人员使用以下三种警告行为：</p>\n<ul>\n<li><code>FutureWarning</code>: 默认情况下始终显示，如果你期望警告能被用户看见，那就用这个。</li>\n<li><code>DeprecationWarning</code>: 在运行单测以及<code>__main__</code>中运行会显示，比较适合开发场景。</li>\n<li><code>PendingDeprecationWarning</code>: 只在运行单测时显示。</li>\n</ul>\n<h3 id=\"充分支持原生类型\"><a href=\"#充分支持原生类型\" class=\"headerlink\" title=\"充分支持原生类型\"></a>充分支持原生类型</h3><p>起初按照PEP484的设计，核心CPython解释器是不会随Python社区和语言的演进而变更。随着类型注解和<code>typing</code>模块在社区中的广泛使用，因为这一限制最终被移除。此次引入两个特殊方法：<code>__class_getitem__()</code>和<code>__mro_entries__()</code>。这两个方法主要在<code>typing</code>中被使用，结果是相关操作的性能得到了七倍的提升。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>3.7最大的问题来自把<code>async</code>和<code>await</code>作为了保留字，不少框架&#x2F;库会面临兼容问题。</p>\n<p>抱着尝新的心态，升级了本机Python，基本无痛切换。</p>\n<p>关于多版本管理，可考虑<code>pipenv</code> + <code>pyenv</code>。前者用于管理虚拟环境，后者主要提供Python版本管理的解决方案，当使用<code>pipenv --python special_version</code>来创建虚拟环境时，<code>pipenv</code>会优先从<code>pyenv</code>的<code>~/.pyenv/versions</code>目录下查找匹配的版本。</p>\n","categories":[],"tags":["Python","语言特性"]},{"title":"理解高性能Python","url":"https://blog.ranchocooper.com/2018/06/24/understand-high-performance-python/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>计算机编程可以认为是对输入数据进行特定的<strong>移动</strong>和<strong>转换</strong>后得到某种结果。通常，在对数据进行这些操作时，会不可避免地产生时间上的开销。因此，高性能编程可以认为通过某些手段来让这些操作的代价最小化，例如：</p>\n<ul>\n<li>降低运行开销（撰写更加高效的代码）</li>\n<li>改变操作方式（寻找更加高效的算法）</li>\n</ul>\n<p>数据的移动发生在实际的硬件上，通常高级语言在背后做了很多工作，将我们对硬件的直接操作进行抽象和封装。理解数据在硬件层面的移动方式以及Python在抽象层面管理数据的方式，可以帮助我们撰写高性能Python代码。</p>\n<h1 id=\"基本的计算机系统\"><a href=\"#基本的计算机系统\" class=\"headerlink\" title=\"基本的计算机系统\"></a>基本的计算机系统</h1><p>一台计算机的底层组件可以分为三大基本部分：<strong>计算单元</strong>，<strong>存储单元</strong>，以及两者之间的<strong>连接方式</strong>。对于计算单元（CPU），我们通常关心它每秒能进行多少次计算，而对于存储单元，我们则关心它能存放多少数据以及它的读写速度是多少。</p>\n<h2 id=\"计算单元\"><a href=\"#计算单元\" class=\"headerlink\" title=\"计算单元\"></a>计算单元</h2><p>一台计算机的计算单元是其中央部件，被大众熟知的CPU就是一种常见的计算单元。值得一提的是，最初被设计于加速图像处理的GPU因其自身的并行计算模式，现在更加适用于数值计算了。无论计算单元是如何架构的，一个计算单元总是会接收一系列的比特，并输出另外一堆比特。</p>\n<p>计算单元的主要属性是其每个周期能进行的操作数量以及每秒能完成多少个周期。衡量第一个属性的是每周期完成的指令数（IPC），而第二个属性则通过时钟速度衡量。这两个参数总是互相竞争。比如Intel的Core系列具有非常高的IPC但时钟速度较低，而Pentium4的芯片则恰好相反。</p>\n<p>当提高IPC时，计算单元的矢量计算能力随之提高，而当时钟速度提高时，能够立即提高该计算单元上所有程序的运行速度，因为这意味着每秒能够进行更多的运算。可能普遍会认为计算机硬件世界始终受摩尔定律影响，但实际上在过去十年，IPC和时钟速度的提升基本处于停滞，因为晶体管已经接近物理上的极限。其结果就是芯片制造商开始依靠其他手段来获得更高的速度，包括超线程技术，乱序执行和多核架构。</p>\n<p>超线程技术为主机的操作系统虚拟了第二个CPU，而聪明的硬件逻辑则试图将两个指令线程交错地插入单个CPU的执行单元。如果插入成功，会比单线程模式提高30%。</p>\n<p>乱序执行允许编译器检测出一个线性程序中不依赖于上下文的部分，可就是说两个部分能够同时进行，而不会互相影响。这使得当一些指令被阻塞时，另一些指令得以执行，以此来提升资源的利用率。</p>\n<p>多核架构在同一个计算单元中包含了多个CPU，提高了总体计算能力。但一味地增加更多核心不一定能提升程序的运行速度。这是由<code>阿姆达尔定律</code>决定的。简单地说，任何并行计算的瓶颈最终都会落到其顺序执行的那部分任务上。</p>\n<h2 id=\"存储单元\"><a href=\"#存储单元\" class=\"headerlink\" title=\"存储单元\"></a>存储单元</h2><p>在计算机存储中，通常存储系统的读写速度与其容量成反比————当我们试图加快读写速度时，存储容量就下降了。因此大部分系统都实现了分层存储。</p>\n<h2 id=\"通信层\"><a href=\"#通信层\" class=\"headerlink\" title=\"通信层\"></a>通信层</h2><p>基本单元之间的通信模式有很多种，但它们都是同一样东西的变种：<code>总线</code>。</p>\n<p>一条总线的主要属性是它的速度：在给定时间内能够传输多少数据。这由两个因素决定：每次传输的数据量（总线带宽）和每秒传输多少次（总线频率）。</p>\n<h1 id=\"Python虚拟机\"><a href=\"#Python虚拟机\" class=\"headerlink\" title=\"Python虚拟机\"></a>Python虚拟机</h1><ul>\n<li>适量操作不再是直接可用的</li>\n<li>内存布局的变化</li>\n<li>GIL影响并行性能</li>\n</ul>\n","categories":[],"tags":["编程札记"]},{"title":"Python 单例模式","url":"https://blog.ranchocooper.com/2018/06/13/singleton-in-python/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>单例模式(Singleton Pattern)是最常见的一种软件设计模式, 该模式的主要目的是<code>保证一个类在程序生命周期内只有一个实例存在</code>.</p>\n<p>比如, 某个服务器程序的配置信息存放在一个文件中, 客户端通过一个<code>AppConfig</code>的类来读取配置文件的信息. 如果在程序运行期间, 有很多地方都需要使用配置文件的内容, 也就是说, 很多地方都需要创建<code>AppConfig</code>对象的实例, 这就导致系统中存在多个<code>AppConfig</code>的实例对象, 而这样会严重浪费内存资源, 尤其是在配置文件内容很多的情况下. 事实上, 类似<code>AppConfig</code>这样的类, 我们希望在程序运行期间只存在一个实例对象. </p>\n<p>在Python中, 有以下方法可以实现单例模式:</p>\n<ul>\n<li>使用模块</li>\n<li>使用装饰器</li>\n<li>使用类</li>\n<li>基于<code>__new__</code></li>\n<li>基于<code>metaclass</code></li>\n</ul>\n<h1 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h1><h2 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h2><p>Python的模块本身就是天然的单例模式, 因为在模块第一次导入时, 就会生成<code>.pyc</code>文件. 当第二次导入时, 就会直接加载<code>.pyc</code>, 而不是再次加载模块代码. 因此, 我们只需要把相关的函数和数据定义在一个模块中, 就可以得到一个单例对象了. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># singleton_module.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">func</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">singleton = Singleton()</span><br></pre></td></tr></table></figure>\n\n<p>在模块中将实例化对象存入变量, 使用时在其他文件中导入即可. 这种方式简单易实现. 得于斯者毁于斯, 因为这种实现方式依赖模块的一次性导入, 如果通过<code>imp.reload</code>重新加载模块, 就会重新实例化对象, 因此并非可靠的单例模式最佳实践.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> singleton_module <span class=\"keyword\">import</span> singleton</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用装饰器\"><a href=\"#使用装饰器\" class=\"headerlink\" title=\"使用装饰器\"></a>使用装饰器</h2><p>装饰器可以动态修改类或函数的功能, 我们通过创建类装饰器来管理实例化对象, 使其只能生成唯一实例, 同样可以实现单例模式.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">singleton</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">    instances = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @wraps(<span class=\"params\">cls</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">getinstance</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> instances:</span><br><span class=\"line\">            instances[cls] = cls(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instances[cls]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getinstance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@singleton</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySingletonClass</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>我们定义一个装饰器, 它在内部维护<code>类: 实例</code>字典, 如果键<code>cls</code>不存在, 则进行实例化, 并将创建的对象作为值存入该字典, 否则直接返回<code>instances[cls]</code>.<br>Note: <strong>不支持多线程</strong></p>\n<h2 id=\"使用类\"><a href=\"#使用类\" class=\"headerlink\" title=\"使用类\"></a>使用类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>\n\n<p>使用多线程, 探究其是否是线程安全的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>():</span><br><span class=\"line\">    obj = Singleton.instance()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = threading.Thread(target=task)</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure>\n\n<p>实测结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10b0d8f98&gt;</span><br></pre></td></tr></table></figure>\n\n<p>乍一看是线程安全的, 实则不然, 因为执行速度过快, 第一个线程其他线程启动前就已经完成了实例的创建工作, 所以其他线程会复用这个实例. 但如果我们在类的<code>__init__</code>方法中加入一些IO操作, 这样一来, 在时序上, 第一个对象的创建要比其他线程的启动要晚, 这样其他线程就会去创建自己的实例对象.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>再次执行代码, 会发现每个线程独会分别创建自己的实例. 由此可见, 这种单例模式的实现方式无法支撑多线程.<br>对于线程安全问题, 解决办法就是<strong>加锁</strong><br>未加锁的代码并发执行, 而加锁代码串行执行, 虽然牺牲了运行速度, 但保证了数据安全.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> Singleton._instance_lock:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&#x27;_instance&#x27;</span>):</span><br><span class=\"line\">                cls._instance = cls(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br></pre></td></tr></table></figure>\n\n<p>实测结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x10ae53e48&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来, 我们就实现了线程安全的单例模式.</p>\n<h3 id=\"改进装饰器\"><a href=\"#改进装饰器\" class=\"headerlink\" title=\"改进装饰器\"></a>改进装饰器</h3><p>同样, 我们可以对装饰器方案也加上线程锁, 来实现线程安全</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">singleton</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">    instances = &#123;&#125;</span><br><span class=\"line\">    instances_lock = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @wraps(<span class=\"params\">cls</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">getinstance</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> instances_lock:</span><br><span class=\"line\">            instances_lock[cls] = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">with</span> instances_lock[cls]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> instances:</span><br><span class=\"line\">                instances[cls] = cls(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instances[cls]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getinstance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@singleton</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySingletonClass</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>通过线程锁, 我们就得到了两种线程安全的单例模式实现方案.<br>横向对比, 如果我们需要定义多个单例类, 装饰器方案可以最大程度地复用代码.</p>\n<h2 id=\"基于-new\"><a href=\"#基于-new\" class=\"headerlink\" title=\"基于__new__\"></a>基于<code>__new__</code></h2><p>在Python中实例化一个对象时, 实际上是执行类的<code>__new__</code>方法, 得到实例对象后, 才会执行<code>__init__</code>方法进行对象初始化<br>而在上面的类实现方式中, 要求我们必须通过<code>obj = Singleton.instance()</code>来实例化对象, 所以更完美的方案是重载<code>__new__</code>方法.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> cls._instance_lock:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(cls, <span class=\"string\">&#x27;_instance&#x27;</span>):</span><br><span class=\"line\">                cls._instance = <span class=\"built_in\">super</span>(Singleton, cls).__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">obj1 = Singleton()</span><br><span class=\"line\">obj2 = Singleton()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(Singleton())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = threading.Thread(target=task)</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基于metaclass\"><a href=\"#基于metaclass\" class=\"headerlink\" title=\"基于metaclass\"></a>基于metaclass</h2><blockquote>\n<p>元类(参考: <a href=\"http://blog.jobbole.com/21351/\">深刻理解Python中的元类</a>)是用于创建类对象的类, 类对象创建实例对象时, 一定会调用<code>__call__</code>方法. 因此在调用<code>__call__</code>时, 保证始终只创建一个实例即可</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(cls)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(cls, <span class=\"string\">&#x27;_instance&#x27;</span>):</span><br><span class=\"line\">            cls._instance = <span class=\"built_in\">super</span>(Singleton, cls).__call__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySingleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    __metaclass__ = Singleton</span><br><span class=\"line\"></span><br><span class=\"line\">c = MySingleton()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>昨天面了小红书基础框架部, 面试中被问到单例模式的实现, 虽然给出了主要的三种实现方案, 但面试官问及线程安全时, 脑子一片空白, 特此补充下这方面的知识.</p>\n<p>本篇主要参考资料:</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/huchong/p/8244279.html\">Python中单例模式的几种实现方式及优化</a></li>\n<li><a href=\"http://python.jobbole.com/87791/\">Python创建单例模式的三种方式</a></li>\n</ul>\n","categories":[],"tags":["编程札记","设计模式","Python"]},{"title":"『译』构建基本对象模型","url":"https://blog.ranchocooper.com/2018/02/28/a-simple-object-model/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p><strong><a href=\"http://aosabook.org/en/500L/a-simple-object-model.html\">原文地址</a></strong></p>\n<p>Carl Friedrich Bolz是一位在伦敦国王大学任职的研究员, 他沉迷于动态语言的实现及优化等领域而不可自拔.  他是PyPy&#x2F;RPython的核心开发者之一, 于此同时, 他也在为Prolog, Racket, Smalltalk, PHP和Ruby等语言贡献代码.</p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>面向对象编程是目前被广泛使用的一种编程范式, 这种编程范式也被大量现代编程语言所支持. 虽然大部分语言给程序猿提供了相似的面向对象的机制, 但是如果深究细节的话, 还是能发现它们之间还是有很多不同的. 大部分的语言的共同点在于都拥有对象处理和继承机制, 而对于类来说的话, 并不是每种语言都完美支持它. 比如对于Self或者JavaScript这样的基于原型继承的语言来说, 其实是没有类这个概念的, 他们的继承行为都是在对象之间所产生的.</p>\n<p>深入了解不同语言的对象模型是一件非常有意思的事儿, 这样我们可以去欣赏不同的编程语言的相似性. 不得不说, 这样的经历可以在我们学习新的语言的时候, 利用上我们已有的经验, 以便于我们快速的掌握它.</p>\n<p>这篇文章将会带领你实现一套简单的对象模型. 首先我们将实现一个简单的类与其实例, 并能够通过这个实例去访问一些方法. 这是被诸如Simula 67, malltalk等早期面向对象语言所采用的面向对象模型. 然后我们会一步步的扩展这个模型, 你可以看到接下来两步会为你展现不同语言的模型设计思路. 然后最后一步是来优化我们的对象模型的性能. 最终我们所得到的模型并不是哪一门真实存在的语言所采用的模型. 不过, 硬是要说的话, 你可以把我们得到的最终模型视为一个低配版的Python对象模型.</p>\n<p>这篇文章里所展现的对象模型都是基于Python实现的. 代码在Python2.7以及Python3.4上都可以完美运行. 为了让大家更好的了解模型里的设计哲学, 本文也为我们所设计的对象模型准备了单元测试, 这些测试代码可以利用py.test或者nose来运行.</p>\n<p>讲真, 用 Python 来作为对象模型的实现语言并不是一个好的选择. 一般而言, 语言的虚拟机都是基于 C&#x2F;C++ 这样更为贴近底层的语言来实现的, 同时在实现中需要非常注意很多的细节, 以保证其执行效率. 不过, Python 这样非常简单的语言能让我们将主要精力都放在不同的行为表现上, 而不是纠结于实现细节不可自拔.</p>\n<h1 id=\"基础方法模型\"><a href=\"#基础方法模型\" class=\"headerlink\" title=\"基础方法模型\"></a>基础方法模型</h1><p>我们将以 Smalltalk 中的实现的非常简单的对象模型来开始讲解我们的对象模型. Smalltalk 是一门由施乐帕克研究中心下属的 Alan Kay 所带领的小组在 70 年代所开发出的一门面向对象语言. 它普及了面向对象编程, 同时在今天的编程语言中依然能看到当时它所包含的很多特性. 在 Smalltalk 核心设计原则之一便是：“万物皆对象”. Smalltalk 最广为人知的继承者是 Ruby, 一门使用类似 C 语言语法的同时保留了 Smalltalk 对象模型的语言.</p>\n<p>在这一部分中, 我们所实现的对象模型将包含类, 实例, 属性的调用及修改, 方法的调用, 同时允许子类的存在. 开始前, 先声明一下, 这里的类都是有他们自己的属性和方法的普通的类</p>\n<p>友情提示：在这篇文章中, “实例”代表着“不是类的对象”的含义.</p>\n<p>一个非常好的习惯就是优先编写测试代码, 以此来约束具体实现的行为. 本文所编写的测试代码由两个部分组成. 第一部分由常规的 Python 代码组成, 可能会使用到 Python 中的类及其余一些更高级的特性. 第二部分将会用我们自己建立的对象模型来替代 Python 的类.</p>\n<p>在编写测试代码时, 我们需要手动维护常规的 Python 类和我们自建类之间的映射关系. 比如, 在我们自定类中将会使用 <code>obj.read_attr(&quot;attribute&quot;)</code> 来作为 Python 中的 <code>obj.attribute</code> 的替代品. 在现实生活中, 这样的映射关系将由语言的编译器&#x2F;解释器来进行实现.</p>\n<p>在本文中, 我们还对模型进行了进一步简化, 这样看起来我们实现对象模型的代码和和编写对象中方法的代码看起来没什么两样. 在现实生活中, 这同样是基本不可能的, 一般而言, 这两者都是由不同的语言实现的.</p>\n<p>首先, 让我们来编写一段用于测试读取求改对象字段的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_read_write_field</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">    obj = A()</span><br><span class=\"line\">    obj.a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.a == <span class=\"number\">1</span></span><br><span class=\"line\">    obj.b = <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.a == <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.b == <span class=\"number\">5</span></span><br><span class=\"line\">    obj.a = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.a == <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.b == <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(A)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;b&quot;</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;b&quot;</span>) == <span class=\"number\">5</span></span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;b&quot;</span>) == <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面这个测试代码中包含了我们必须实现的三个东西. <code>Class</code> 以及 <code>Instance</code> 类分别代表着我们对象中的类以及实例. 同时这里有两个特殊的类的实例：<code>OBJECT</code> 和 <code>TYPE</code>.  <code>OBJECT</code> 对应的是作为 Python 继承系统起点的 <code>object</code> 类（在 Python 2.x 版本中, 实际上是有两套类系统, 一套被统称为 new style class 的新式类, 一套被称为 old style class 的经典类, object 是 new style class 的基类）. <code>TYPE</code> 对应的是 Python 类型系统中的 <code>type</code> .</p>\n<p>为了给 <code>Class</code> 以及 <code>Instance</code> 类的实例提供通用操作支持, 这两个类都会从 <code>Base</code> 类这样提供了一系列方法的基础类中进行继承并实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot; The base class that all of the object model classes inherit from. &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, cls, fields</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; Every object has a class. &quot;&quot;&quot;</span></span><br><span class=\"line\">        self.cls = cls</span><br><span class=\"line\">        self._fields = fields</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">read_attr</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._read_dict(fieldname)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">write_attr</span>(<span class=\"params\">self, fieldname, value</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; write field &#x27;fieldname&#x27; into the object &quot;&quot;&quot;</span></span><br><span class=\"line\">        self._write_dict(fieldname, value)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">isinstance</span>(<span class=\"params\">self, cls</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; return True if the object is an instance of class cls &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.cls.<span class=\"built_in\">issubclass</span>(cls)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">callmethod</span>(<span class=\"params\">self, methname, *args</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; call method &#x27;methname&#x27; with arguments &#x27;args&#x27; on object &quot;&quot;&quot;</span></span><br><span class=\"line\">        meth = self.cls._read_from_class(methname)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> meth(self, *args)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_read_dict</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; read an field &#x27;fieldname&#x27; out of the object&#x27;s dict &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._fields.get(fieldname, MISSING)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_write_dict</span>(<span class=\"params\">self, fieldname, value</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; write a field &#x27;fieldname&#x27; into the object&#x27;s dict &quot;&quot;&quot;</span></span><br><span class=\"line\">        self._fields[fieldname] = value</span><br><span class=\"line\"></span><br><span class=\"line\">MISSING = <span class=\"built_in\">object</span>()</span><br></pre></td></tr></table></figure>\n\n<p><code>Base</code> 实现了对象类的储存, 同时也使用了一个字典来保存对象字段的值. 现在, 我们需要去实现 <code>Class</code> 以及 <code>Instance</code> 类. 在<code>Instance</code> 的构造器中将会完成类的实例化以及 <code>fields</code> 和 <code>dict</code> 初始化的操作. 换句话说, <code>Instance</code> 只是 <code>Base</code> 的子类, 同时并不会为其添加额外的方法.</p>\n<p><code>Class</code> 的构造器将会接受类名、基础类、类字典、以及元类这样几个操作. 对于类来讲, 上面几个变量都会在类初始化的时候由用户传递给构造器. 同时构造器也会从它的基类那里获取变量的默认值. 不过这个点, 我们将在下一章节进行讲述.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Instance</span>(<span class=\"title class_ inherited__\">Base</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, cls</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(cls, Class)</span><br><span class=\"line\">        Base.__init__(self, cls, &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Class</span>(<span class=\"title class_ inherited__\">Base</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot; A User-defined class. &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name, base_class, fields, metaclass</span>):</span><br><span class=\"line\">        Base.__init__(self, metaclass, fields)</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.base_class = base_class</span><br></pre></td></tr></table></figure>\n\n<p>同时, 你可能注意到这点, 类依旧是一种特殊的对象, 他们间接的从 Base 中继承. 因此, 类也是一个特殊类的特殊实例, 这样的很特殊的类叫做：元类.</p>\n<p>现在, 我们可以顺利通过我们第一组测试. 不过这里, 我们还没有定义 <code>Type</code> 以及 <code>OBJECT</code> 这样两个 <code>Class</code> 的实例. 对于这些东西, 我们将不会按照 Smalltalk 的对象模型进行构建, 因为 Smalltalk 的对象模型对于我们来说太过于复杂. 作为替代品, 我们将采用 ObjVlisp1 的类型系统, Python 的类型系统从这里吸收了不少东西.</p>\n<p>在 ObjVlisp 的对象模型中, <code>OBJECT</code> 以及 <code>TYPE</code> 是交杂在一起的. <code>OBJECT</code> 是所有类的母类, 意味着 <code>OBJECT</code> 没有母类. <code>TYPE</code> 是 <code>OBJECT</code> 的子类. 一般而言, 每一个类都是 <code>TYPE</code> 的实例. 在特定情况下, <code>TYPE</code> 和 <code>OBJECT</code> 都是 <code>TYPE</code> 的实例. 不过, 程序猿可以从 <code>TYPE</code> 派生出一个类去作为元类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># set up the base hierarchy as in Python (the ObjVLisp model)</span></span><br><span class=\"line\"><span class=\"comment\"># the ultimate base class is OBJECT</span></span><br><span class=\"line\">OBJECT = Class(name=<span class=\"string\">&quot;object&quot;</span>, base_class=<span class=\"literal\">None</span>, fields=&#123;&#125;, metaclass=<span class=\"literal\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># TYPE is a subclass of OBJECT</span></span><br><span class=\"line\">TYPE = Class(name=<span class=\"string\">&quot;type&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=<span class=\"literal\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># TYPE is an instance of itself</span></span><br><span class=\"line\">TYPE.cls = TYPE</span><br><span class=\"line\"><span class=\"comment\"># OBJECT is an instance of TYPE</span></span><br><span class=\"line\">OBJECT.cls = TYPE</span><br></pre></td></tr></table></figure>\n\n<p>为了去编写一个新的元类, 我们需要自行从 <code>TYPE</code> 进行派生. 不过在本文中我们并不会这么做, 我们将只会使用 <code>TYPE</code> 作为我们每个类的元类.</p>\n<p>![Figure - Inheritance](Figure - Inheritance.jpg)<br><small class=\"img-hint\">Figure - Inheritance</small></p>\n<p>好了, 现在第一组测试已经完全通过了. 现在让我们来看看第二组测试, 我们将会在这组测试中测试对象属性读写是否正常. 这段代码还是很好写的.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_read_write_field_class</span>():</span><br><span class=\"line\">    <span class=\"comment\"># classes are objects too</span></span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    A.a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> A.a == <span class=\"number\">1</span></span><br><span class=\"line\">    A.a = <span class=\"number\">6</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> A.a == <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class=\"string\">&quot;a&quot;</span>: <span class=\"number\">1</span>&#125;, metaclass=TYPE)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> A.read_attr(<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">    A.write_attr(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> A.read_attr(<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"isinstance-检查\"><a href=\"#isinstance-检查\" class=\"headerlink\" title=\"isinstance 检查\"></a>isinstance 检查</h2><p>到目前为止, 我们还没有将对象有类这点特性利用起来. 接下来的测试代码将会自动的实现 <code>isinstance</code> .</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_isinstance</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>(<span class=\"title class_ inherited__\">A</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    b = B()</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(b, B)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(b, A)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(b, <span class=\"built_in\">object</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(b, <span class=\"built_in\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class=\"line\">    B = Class(name=<span class=\"string\">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class=\"line\">    b = Instance(B)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> b.<span class=\"built_in\">isinstance</span>(B)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> b.<span class=\"built_in\">isinstance</span>(A)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> b.<span class=\"built_in\">isinstance</span>(OBJECT)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"keyword\">not</span> b.<span class=\"built_in\">isinstance</span>(TYPE)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过检查 <code>cls</code> 是不是 <code>obj</code> 类或者它自己的超类来判断 <code>obj</code> 对象是不是某些类 <code>cls</code> 的实例. 通过检查一个类是否在一个超类链上工作, 来判断一个类是不是另一个类的超类. 如果还有其余类存在于这个超类链上, 那么这些类也可以被称为是超类. 这个包含了超类和类本身的链条, 被称之为方法解析顺序（简称MRO）. 它很容易以递归的方式进行计算：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Class</span>(<span class=\"title class_ inherited__\">Base</span>):</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">method_resolution_order</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; compute the method resolution order of the class &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.base_class <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [self]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [self] + self.base_class.method_resolution_order()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">issubclass</span>(<span class=\"params\">self, cls</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; is self a subclass of cls? &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls <span class=\"keyword\">in</span> self.method_resolution_order()</span><br></pre></td></tr></table></figure>\n\n<p>好了, 在修改代码后, 测试就完全能通过了</p>\n<h2 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h2><p>前面所建立的对象模型中还缺少了方法调用这样的重要特性. 在本章我们将会建立一个简单的继承模型.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_callmethod_simple</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">f</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.x + <span class=\"number\">1</span></span><br><span class=\"line\">    obj = A()</span><br><span class=\"line\">    obj.x = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.f() == <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>(<span class=\"title class_ inherited__\">A</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    obj = B()</span><br><span class=\"line\">    obj.x = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.f() == <span class=\"number\">2</span> <span class=\"comment\"># works on subclass too</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">f_A</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.read_attr(<span class=\"string\">&quot;x&quot;</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class=\"string\">&quot;f&quot;</span>: f_A&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(A)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.callmethod(<span class=\"string\">&quot;f&quot;</span>) == <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    B = Class(name=<span class=\"string\">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(B)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.callmethod(<span class=\"string\">&quot;f&quot;</span>) == <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>为了找到调用对象方法的正确实现, 我们现在开始讨论类对象的方法解析顺序. 在 MRO 中我们所寻找到的类对象字典中第一个方法将会被调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Class</span>(<span class=\"title class_ inherited__\">Base</span>):</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_read_from_class</span>(<span class=\"params\">self, methname</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> cls <span class=\"keyword\">in</span> self.method_resolution_order():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> methname <span class=\"keyword\">in</span> cls._fields:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cls._fields[methname]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MISSING</span><br></pre></td></tr></table></figure>\n\n<p>在完成 <code>Base</code> 类中 <code>callmethod</code> 实现后, 可以通过上面的测试.</p>\n<p>为了保证函数参数传递正确, 同时也确保我们事先的代码能完成方法重载的功能, 我们可以编写下面这段测试代码, 当然结果是完美通过测试：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_callmethod_subclassing_and_arguments</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">g</span>(<span class=\"params\">self, arg</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.x + arg</span><br><span class=\"line\">    obj = A()</span><br><span class=\"line\">    obj.x = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.g(<span class=\"number\">4</span>) == <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>(<span class=\"title class_ inherited__\">A</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">g</span>(<span class=\"params\">self, arg</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.x + arg * <span class=\"number\">2</span></span><br><span class=\"line\">    obj = B()</span><br><span class=\"line\">    obj.x = <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.g(<span class=\"number\">4</span>) == <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">g_A</span>(<span class=\"params\">self, arg</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.read_attr(<span class=\"string\">&quot;x&quot;</span>) + arg</span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class=\"string\">&quot;g&quot;</span>: g_A&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(A)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.callmethod(<span class=\"string\">&quot;g&quot;</span>, <span class=\"number\">4</span>) == <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">g_B</span>(<span class=\"params\">self, arg</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.read_attr(<span class=\"string\">&quot;x&quot;</span>) + arg * <span class=\"number\">2</span></span><br><span class=\"line\">    B = Class(name=<span class=\"string\">&quot;B&quot;</span>, base_class=A, fields=&#123;<span class=\"string\">&quot;g&quot;</span>: g_B&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(B)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.callmethod(<span class=\"string\">&quot;g&quot;</span>, <span class=\"number\">4</span>) == <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基础属性模型\"><a href=\"#基础属性模型\" class=\"headerlink\" title=\"基础属性模型\"></a>基础属性模型</h1><p>现在最简单版本的对象模型已经可以开始工作了, 不过我们还需要去不断的改进. 这一部分将会介绍基础方法模型和基础属性模型之间的差异. 这也是 Smalltalk 、 Ruby 、 JavaScript 、 Python 和 Lua 之间的核心差异.</p>\n<p>基础方法模型将会按照最原始的方式去调用方法：</p>\n<pre><code>result = obj.f(arg1, arg2)\n</code></pre>\n<p>基础属性模型将会将调用过程分为两步：寻找属性, 以及返回执行结果：</p>\n<pre><code>method = obj.f\nresult = method(arg1, arg2)\n</code></pre>\n<p>你可以在接下来的测试中体会到前文所述的差异：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_bound_method</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">f</span>(<span class=\"params\">self, a</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.x + a + <span class=\"number\">1</span></span><br><span class=\"line\">    obj = A()</span><br><span class=\"line\">    obj.x = <span class=\"number\">2</span></span><br><span class=\"line\">    m = obj.f</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> m(<span class=\"number\">4</span>) == <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>(<span class=\"title class_ inherited__\">A</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    obj = B()</span><br><span class=\"line\">    obj.x = <span class=\"number\">1</span></span><br><span class=\"line\">    m = obj.f</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> m(<span class=\"number\">10</span>) == <span class=\"number\">12</span> <span class=\"comment\"># works on subclass too</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">f_A</span>(<span class=\"params\">self, a</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.read_attr(<span class=\"string\">&quot;x&quot;</span>) + a + <span class=\"number\">1</span></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class=\"string\">&quot;f&quot;</span>: f_A&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(A)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    m = obj.read_attr(<span class=\"string\">&quot;f&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> m(<span class=\"number\">4</span>) == <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">    B = Class(name=<span class=\"string\">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(B)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    m = obj.read_attr(<span class=\"string\">&quot;f&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> m(<span class=\"number\">10</span>) == <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以按照之前测试代码中对方法调用设置一样的步骤去设置属性调用, 不过和方法调用相比, 这里面发生了一些变化. 首先, 我们将会在对象中寻找与函数名对应的方法名. 这样一个查找过程结果被称之为已绑定的方法, 具体来说就是, 这个结果一个绑定了方法与具体对象的特殊对象. 然后这个绑定方法会在接下来的操作中被调用.</p>\n<p>为了实现这样的操作, 我们需要修改 <code>Base.read_attr</code> 的实现. 如果在实例字典中没有找到对应的属性, 那么我们需要去在类字典中查找. 如果在类字典中查找到了这个属性, 那么我们将会执行方法绑定的操作. 我们可以使用一个闭包来很简单的模拟绑定方法. 除了更改 <code>Base.read_attr</code> 实现以外, 我们也可以修改 <code>Base.callmethod</code> 方法来确保我们代码能通过测试.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">read_attr</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class=\"line\">        result = self._read_dict(fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> MISSING:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        result = self.cls._read_from_class(fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> _is_bindable(result):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _make_boundmethod(result, self)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> MISSING:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> AttributeError(fieldname)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">callmethod</span>(<span class=\"params\">self, methname, *args</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; call method &#x27;methname&#x27; with arguments &#x27;args&#x27; on object &quot;&quot;&quot;</span></span><br><span class=\"line\">        meth = self.read_attr(methname)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> meth(*args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_is_bindable</span>(<span class=\"params\">meth</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">callable</span>(meth)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_make_boundmethod</span>(<span class=\"params\">meth, self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">bound</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> meth(self, *args)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bound</span><br></pre></td></tr></table></figure>\n\n<p>其余的代码并不需要修改.</p>\n<h2 id=\"元对象协议\"><a href=\"#元对象协议\" class=\"headerlink\" title=\"元对象协议\"></a>元对象协议</h2><p>除了常规的类方法之外, 很多动态语言还支持特殊方法. 有这样一些方法在调用时是由对象系统调用而不是使用常规调用. 在 Python 中你可以看到这些方法的方法名用两个下划线作为开头和结束的, 比如 <code>__init__</code> . 特殊方法可以用于重载一些常规操作, 同时可以提供一些自定义的功能. 因此, 它们的存在可以告诉对象模型如何自动的处理不同的事情. Python 中相关特殊方法的说明可以查看<a href=\"https://docs.python.org/3/reference/datamodel.html#special-method-names\">这篇文档</a>.</p>\n<p>元对象协议这一概念由 Smalltalk 引入, 然后在诸如 CLOS 这样的通用 Lisp 的对象模型中也广泛的使用这个概念. 这个概念包含特殊方法的集合（注：这里没有查到 coined3 的梗, 请校者帮忙参考）.</p>\n<p>在这一章中, 我们将会为我们的对象模型添加三个元调用操作. 它们将会用来对我们读取和修改对象的操作进行更为精细的控制. 我们首先要添加的两个方法是 <code>__getattr__</code> 和 <code>__setattr__</code>,  这两个方法的命名看起来和我们 Python 中相同功能函数的方法名很相似.</p>\n<h2 id=\"自定义属性读写操作\"><a href=\"#自定义属性读写操作\" class=\"headerlink\" title=\"自定义属性读写操作\"></a>自定义属性读写操作</h2><p><code>__getattr__</code> 方法将会在属性通过常规方法无法查找到的情况下被调用, 换句话说, 在实例字典、类字典、父类字典等等对象中都找不到对应的属性时, 会触发该方法的调用. 我们将传入一个被查找属性的名字作为这个方法的参数. 在早期的 Smalltalk4 中这个方法被称为 <code>doesNotUnderstand</code> .</p>\n<p>在 <code>__setattr__</code> 这里事情可能发生了点变化. 首先我们需要明确一点的是, 设置一个属性的时候通常意味着我们需要创建它, 在这个时候, 在设置属性的时候通常会触发 <code>__setattr__</code> 方法. 为了确保 <code>__setattr__</code> 的存在, 我们需要在 <code>OBJECT</code> 对象中实现 <code>__setattr__</code> 方法. 这样最基础的实现完成了我们向相对应的字典里写入属性的操作. 这可以使得用户可以将自己定义的 <code>__setattr__</code> 委托给 <code>OBJECT.__setattr__</code> 方法.</p>\n<p>针对这两个特殊方法的测试用例如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_getattr</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">__getattr__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;fahrenheit&quot;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.celsius * <span class=\"number\">9</span>\\. / <span class=\"number\">5</span>\\. + <span class=\"number\">32</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(name)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">__setattr__</span>(<span class=\"params\">self, name, value</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;fahrenheit&quot;</span>:</span><br><span class=\"line\">                self.celsius = (value - <span class=\"number\">32</span>) * <span class=\"number\">5</span>\\. / <span class=\"number\">9.</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"comment\"># call the base implementation</span></span><br><span class=\"line\">                <span class=\"built_in\">object</span>.__setattr__(self, name, value)</span><br><span class=\"line\">    obj = A()</span><br><span class=\"line\">    obj.celsius = <span class=\"number\">30</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.fahrenheit == <span class=\"number\">86</span> <span class=\"comment\"># test __getattr__</span></span><br><span class=\"line\">    obj.celsius = <span class=\"number\">40</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.fahrenheit == <span class=\"number\">104</span></span><br><span class=\"line\"></span><br><span class=\"line\">    obj.fahrenheit = <span class=\"number\">86</span> <span class=\"comment\"># test __setattr__</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.celsius == <span class=\"number\">30</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.fahrenheit == <span class=\"number\">86</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__getattr__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;fahrenheit&quot;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.read_attr(<span class=\"string\">&quot;celsius&quot;</span>) * <span class=\"number\">9</span>\\. / <span class=\"number\">5</span>\\. + <span class=\"number\">32</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> AttributeError(name)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__setattr__</span>(<span class=\"params\">self, name, value</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;fahrenheit&quot;</span>:</span><br><span class=\"line\">            self.write_attr(<span class=\"string\">&quot;celsius&quot;</span>, (value - <span class=\"number\">32</span>) * <span class=\"number\">5</span>\\. / <span class=\"number\">9.</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"comment\"># call the base implementation</span></span><br><span class=\"line\">            OBJECT.read_attr(<span class=\"string\">&quot;__setattr__&quot;</span>)(self, name, value)</span><br><span class=\"line\"></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT,</span><br><span class=\"line\">              fields=&#123;<span class=\"string\">&quot;__getattr__&quot;</span>: __getattr__, <span class=\"string\">&quot;__setattr__&quot;</span>: __setattr__&#125;,</span><br><span class=\"line\">              metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(A)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;celsius&quot;</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;fahrenheit&quot;</span>) == <span class=\"number\">86</span> <span class=\"comment\"># test __getattr__</span></span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;celsius&quot;</span>, <span class=\"number\">40</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;fahrenheit&quot;</span>) == <span class=\"number\">104</span></span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;fahrenheit&quot;</span>, <span class=\"number\">86</span>) <span class=\"comment\"># test __setattr__</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;celsius&quot;</span>) == <span class=\"number\">30</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;fahrenheit&quot;</span>) == <span class=\"number\">86</span></span><br></pre></td></tr></table></figure>\n\n<p>为了通过测试, 我们需要修改下 <code>Base.read_attr</code> 以及 <code>Base.write_attr</code> 两个方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">read_attr</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class=\"line\">        result = self._read_dict(fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> MISSING:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        result = self.cls._read_from_class(fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> _is_bindable(result):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _make_boundmethod(result, self)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> MISSING:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        meth = self.cls._read_from_class(<span class=\"string\">&quot;__getattr__&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> meth <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> MISSING:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> meth(self, fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> AttributeError(fieldname)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">write_attr</span>(<span class=\"params\">self, fieldname, value</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; write field &#x27;fieldname&#x27; into the object &quot;&quot;&quot;</span></span><br><span class=\"line\">        meth = self.cls._read_from_class(<span class=\"string\">&quot;__setattr__&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> meth(self, fieldname, value)</span><br></pre></td></tr></table></figure>\n\n<p>获取属性的过程变成调用 <code>__getattr__</code> 方法并传入字段名作为参数, 如果字段不存在, 将会抛出一个异常. 请注意 <code>__getattr__</code> 只能在类中调用（Python 中的特殊方法也是这样）, 同时需要避免这样的 <code>self.read_attr(&quot;__getattr__&quot;)</code> 递归调用, 因为如果 <code>__getattr__</code> 方法没有定义的话, 上面的调用会造成无限递归.</p>\n<p>对属性的修改操作也会像读取一样交给 <code>__setattr__</code> 方法执行. 为了保证这个方法能够正常执行, <code>OBJECT</code> 需要实现 <code>__setattr__</code> 的默认行为, 比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">OBJECT__setattr__</span>(<span class=\"params\">self, fieldname, value</span>):</span><br><span class=\"line\">    self._write_dict(fieldname, value)</span><br><span class=\"line\">OBJECT = Class(<span class=\"string\">&quot;object&quot;</span>, <span class=\"literal\">None</span>, &#123;<span class=\"string\">&quot;__setattr__&quot;</span>: OBJECT__setattr__&#125;, <span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>OBJECT.__setattr__</code> 的具体实现和之前 <code>write_attr</code> 方法的实现有着相似之处. 在完成这些修改后, 我们可以顺利的通过我们的测试.</p>\n<h2 id=\"描述符协议\"><a href=\"#描述符协议\" class=\"headerlink\" title=\"描述符协议\"></a>描述符协议</h2><p>在上面的测试中, 我们频繁的在不同的温标之间切换, 不得不说, 在执行修改属性操作的时候这样真的很蛋疼, 所以我们需要在 <code>__getattr__</code> 和 <code>__setattr__</code> 中检查所使用的的属性的名称为了解决这个问题, 在 Python 中引入了<strong>描述符协议</strong>的概念.</p>\n<p>我们将从 <code>__getattr__</code> 和 <code>__setattr__</code> 方法中获取具体的属性, 而描述符协议则是在属性调用过程结束返回结果时触发一个特殊的方法. 描述符协议可以视为一种可以绑定类与方法的特殊手段, 我们可以使用描述符协议来完成将方法绑定到对象的具体操作. 除了绑定方法, 在 Python 中描述符最重要的几个使用场景之一就是 <code>staticmethod</code>、 <code>classmethod</code> 和 <code>property</code>.</p>\n<p>在接下来一点文字中, 我们将介绍怎么样来使用描述符进行对象绑定. 我们可以通过使用 <code>__get__</code> 方法来达成这一目标, 具体请看下面的测试代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_get</span>():</span><br><span class=\"line\">    <span class=\"comment\"># Python code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">FahrenheitGetter</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">__get__</span>(<span class=\"params\">self, inst, cls</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> inst.celsius * <span class=\"number\">9</span>\\. / <span class=\"number\">5</span>\\. + <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        fahrenheit = FahrenheitGetter()</span><br><span class=\"line\">    obj = A()</span><br><span class=\"line\">    obj.celsius = <span class=\"number\">30</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.fahrenheit == <span class=\"number\">86</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Object model code</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">FahrenheitGetter</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">__get__</span>(<span class=\"params\">self, inst, cls</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> inst.read_attr(<span class=\"string\">&quot;celsius&quot;</span>) * <span class=\"number\">9</span>\\. / <span class=\"number\">5</span>\\. + <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">    A = Class(name=<span class=\"string\">&quot;A&quot;</span>, base_class=OBJECT,</span><br><span class=\"line\">              fields=&#123;<span class=\"string\">&quot;fahrenheit&quot;</span>: FahrenheitGetter()&#125;,</span><br><span class=\"line\">              metaclass=TYPE)</span><br><span class=\"line\">    obj = Instance(A)</span><br><span class=\"line\">    obj.write_attr(<span class=\"string\">&quot;celsius&quot;</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> obj.read_attr(<span class=\"string\">&quot;fahrenheit&quot;</span>) == <span class=\"number\">86</span></span><br></pre></td></tr></table></figure>\n\n<p><code>__get__</code> 方法将会在属性查找完后被 <code>FahrenheitGetter</code> 实例所调用. 传递给 <code>__get__</code> 的参数是查找过程结束时所处的那个实例.</p>\n<p>实现这样的功能倒是很简单, 我们可以很简单的修改 <code>_is_bindable</code> 和 <code>_make_boundmethod</code> 方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_is_bindable</span>(<span class=\"params\">meth</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hasattr</span>(meth, <span class=\"string\">&quot;__get__&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_make_boundmethod</span>(<span class=\"params\">meth, self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> meth.__get__(self, <span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p>好了, 这样简单的修改能保证我们通过测试了. 之前关于方法绑定的测试也能通过了, 在 Python 中 <code>__get__</code> 方法执行完了将会返回一个已绑定方法对象.</p>\n<p>在实践中, 描述符协议的确看起来比较复杂. 它同时还包含用于设置属性的 <code>__set__</code> 方法. 此外, 你现在所看到我们实现的版本是经过一些简化的. 请注意, 前面 <code>_make_boundmethod</code> 方法调用 <code>__get__</code> 是实现级的操作, 而不是使用 <code>meth.read_attr(&#39;__get__&#39;)</code> . 这是很有必要的, 因为我们的对象模型只是从 Python 中借用函数和方法, 而不是展示 Python 的对象模型. 进一步完善模型的话可以有效解决这个问题.</p>\n<h1 id=\"实例优化\"><a href=\"#实例优化\" class=\"headerlink\" title=\"实例优化\"></a>实例优化</h1><p>这个对象模型前面三个部分的建立过程中伴随着很多的行为变化, 而最后一部分的优化工作并不会伴随着行为变化. 这种优化方式被称为 map ,广泛存在在可以自举的语言虚拟机中. 这是一种最ä¸º重要对象模型优化手段：在 PyPy , 诸如 V8 现代 JavaScript 虚拟机中得到应用（在 V8 中这种方法被称为 hidden classes）.</p>\n<p>这种优化手段基于如下的观察：到目前所实现的对象模型中, 所有实例都使用一个完整的字典来储存他们的属性. 字典是基于哈希表进行实现的, 这将会耗费大量的内存. 在很多时候, 同一个类的实例将会拥有同样的属性, 比如, 有一个类 <code>Point</code> , 它所有的实例都包含同样的属性 <code>x</code> <code>y</code>.</p>\n<p><code>Map</code> 优化利用了这样一个事实. 它将会将每个实例的字典分割为两个部分. 一部分存放可以在所有实例中共享的属性名. 然后另一部分只存放对第一部分产生的 <code>Map</code> 的引用和存放具体的值. 存放属性名的 <strong>map</strong> 将会作为值的索引.</p>\n<p>我们将为上面所述的需求编写一些测试用例, 如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_maps</span>():</span><br><span class=\"line\">    <span class=\"comment\"># white box test inspecting the implementation</span></span><br><span class=\"line\">    Point = Class(name=<span class=\"string\">&quot;Point&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class=\"line\">    p1 = Instance(Point)</span><br><span class=\"line\">    p1.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    p1.write_attr(<span class=\"string\">&quot;y&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p1.storage == [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p1.<span class=\"built_in\">map</span>.attrs == &#123;<span class=\"string\">&quot;x&quot;</span>: <span class=\"number\">0</span>, <span class=\"string\">&quot;y&quot;</span>: <span class=\"number\">1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p2 = Instance(Point)</span><br><span class=\"line\">    p2.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    p2.write_attr(<span class=\"string\">&quot;y&quot;</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p1.<span class=\"built_in\">map</span> <span class=\"keyword\">is</span> p2.<span class=\"built_in\">map</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p2.storage == [<span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    p1.write_attr(<span class=\"string\">&quot;x&quot;</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">    p1.write_attr(<span class=\"string\">&quot;y&quot;</span>, -<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p1.<span class=\"built_in\">map</span> <span class=\"keyword\">is</span> p2.<span class=\"built_in\">map</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p1.storage == [-<span class=\"number\">1</span>, -<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    p3 = Instance(Point)</span><br><span class=\"line\">    p3.write_attr(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">    p3.write_attr(<span class=\"string\">&quot;z&quot;</span>, -<span class=\"number\">343</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p3.<span class=\"built_in\">map</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> p1.<span class=\"built_in\">map</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> p3.<span class=\"built_in\">map</span>.attrs == &#123;<span class=\"string\">&quot;x&quot;</span>: <span class=\"number\">0</span>, <span class=\"string\">&quot;z&quot;</span>: <span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意, 这里测试代码的风格和我们之前的才是代码看起不太一样. 之前所有的测试只是通过已实现的接口来测试类的功能. 这里的测试通过读取类的内部属性来获取实现的详细信息, 并将其与预设的值进行比较. 这种测试方法又被称之为白盒测试.</p>\n<p><code>p1</code> 的包含 <code>attrs</code> 的 <code>map</code> 存放了 <code>x</code> 和 <code>y</code> 两个属性, 其在 <code>p1</code> 中存放的值分别为 0 和 1. 然后创建第二个实例 <code>p2</code> , 并通过同样的方法网同样的 <code>map</code> 中添加同样的属性.  换句话说, 如果不同的属性被添加了, 那么其中的 <code>map</code> 是不通用的.</p>\n<p><code>Map</code> 类长下面这样：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Map</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, attrs</span>):</span><br><span class=\"line\">        self.attrs = attrs</span><br><span class=\"line\">        self.next_maps = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_index</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.attrs.get(fieldname, -<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next_map</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> fieldname <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.attrs</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fieldname <span class=\"keyword\">in</span> self.next_maps:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.next_maps[fieldname]</span><br><span class=\"line\">        attrs = self.attrs.copy()</span><br><span class=\"line\">        attrs[fieldname] = <span class=\"built_in\">len</span>(attrs)</span><br><span class=\"line\">        result = self.next_maps[fieldname] = Map(attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">EMPTY_MAP = Map(&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>Map</code> 类拥有两个方法, 分别是 <code>get_index</code> 和 <code>next_map</code> . 前者用于查找对象储存空间中的索引中查找对应的属性名称. 而在新的属性添加到对象中时应该使用后者. 在这种情况下, 不同的实例需要用 <code>next_map</code> 计算不同的映射关系. 这个方法将会使用 <code>next_maps</code> 来查找已经存在的映射. 这样, 相似的实例将会使用相似的 <code>Map</code> 对象.</p>\n<p>![Figure - Map transitions](Figure - Map transitions.jpg)<br><small class=\"img-hint\">Figure - Map transitions</small></p>\n<p>使用 <code>map</code> 的 <code>Instance</code> 实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Instance</span>(<span class=\"title class_ inherited__\">Base</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, cls</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(cls, Class)</span><br><span class=\"line\">        Base.__init__(self, cls, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        self.<span class=\"built_in\">map</span> = EMPTY_MAP</span><br><span class=\"line\">        self.storage = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_read_dict</span>(<span class=\"params\">self, fieldname</span>):</span><br><span class=\"line\">        index = self.<span class=\"built_in\">map</span>.get_index(fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> MISSING</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.storage[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_write_dict</span>(<span class=\"params\">self, fieldname, value</span>):</span><br><span class=\"line\">        index = self.<span class=\"built_in\">map</span>.get_index(fieldname)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index != -<span class=\"number\">1</span>:</span><br><span class=\"line\">            self.storage[index] = value</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            new_map = self.<span class=\"built_in\">map</span>.next_map(fieldname)</span><br><span class=\"line\">            self.storage.append(value)</span><br><span class=\"line\">            self.<span class=\"built_in\">map</span> = new_map</span><br></pre></td></tr></table></figure>\n\n<p>现在这个类将给 <code>Base</code> 类传递 <code>None</code> 作为字段字典, 那是因为 <code>Instance</code> 将会以另一种方式构建存储字典. 因此它需要重载 <code>_read_dict</code> 和 <code>_write_dict</code> . 在实际操作中, 我们将重构 <code>Base</code> 类, 使其不在负责存放字段字典. 不过眼下, 我们传递一个 <code>None</code> 作为参数就足够了.</p>\n<p>在一个新的实例创建之初使用的是 <code>EMPTY_MAP</code> , 这里面没有任何的对象存放着. 在实现 <code>_read_dict</code> 后, 我们将从实例的 <code>map</code> 中查找属性名的索引, 然后映射相对应的储存表.</p>\n<p>向字段字典写入数据分为两种情况. 第一种是现有属性值的修改, 那么就简单的在映射的列表中修改对应的值就好. 而如果对应属性不存在, 那么需要进行 <code>map</code> 变换（如上面的图所示一样）, 将会调用 <code>next_map</code> 方法, 然后将新的值存放入储存列表中.</p>\n<p>你肯定想问, 这种优化方式到底优化了什么？一般而言, 在具有很多相似结构实例的情况下能较好的优化内存. 但是请记住, 这不是一个通用的优化手段. 有些时候代码中充斥着结构不同的实例之时, 这种手段可能会耗费更大的空间.</p>\n<p>这是动态语言优化中的常见问题. 一般而言, 不太可能找到一种万能的方法去优化代码, 使其更快, 更节省空间. 因此, 具体情况具体分析, 我们需要根据不同的情况去选择优化方式.</p>\n<p>在 <code>Map</code> 优化中很有意思的一点就是, 虽然这里只有花了内存占用, 但是在 VM 使用 JIT 技术的情况下, 也能较好的提高程序的性能. 为了实现这一点, JIT 技术使用映射来查找属性在存储空间中的偏移量. 然后完全除去字典查找的方式.</p>\n<h1 id=\"潜在扩展\"><a href=\"#潜在扩展\" class=\"headerlink\" title=\"潜在扩展\"></a>潜在扩展</h1><p>扩展我们的对象模型和引入不同语言的设计选择是一件非常容易的事儿. 这里给出一些可能的方向：</p>\n<ul>\n<li><p>最简单的是添加更多的特殊方法方法, 比如一些 <code>__init__</code>, <code>__getattribute__</code>, <code>__set__</code> 这样非常容易实现和有趣的方法.</p>\n</li>\n<li><p>扩展模型支持多重继承. 为了实现这一点, 每一个类都需要一个父类列表. 然后 <code>Class.method_resolution_order</code> 需要进行修改, 以便支持方法查找. 一个简单的 MRO 计算规则可以使用深度优先原则. 然后更为复杂的可以采用<a href=\"https://www.python.org/download/releases/2.3/mro/\">C3 算法</a>, 这种算法能更好的处理菱形继承结构所带来的一些问题.</p>\n</li>\n<li><p>一个更为疯狂的想法是切换到原型模式, 这需要消除类和实例之间的差别.</p>\n</li>\n</ul>\n<p>总结<br>面向对象编程语言设计的核心是其对象模型的细节. 编写一些简单的对象模型是一件非常简单而且有趣的事情. 你可以通过这种方式来了解现有语言的工作机制, 并且深入了解面向对象语言的设计原则. 编写不同的对象模型验证不同对象的设计思路是一个非常棒的方法. 你也不在需要将注意力放在其余一些琐碎的事情上, 比如解析和执行代码.</p>\n<p>这样编写对象模型的工作在实践中也是非常有用的. 除了作为实验品以外, 它们还可以被其余语言所使用. 这种例子有很多：比如 GObject 模型, 用 C 语言编写, 在 GLib 和 其余 Gonme 中得到使用, 还有就是用 JavaScript 实现的各类对象模型.</p>\n","categories":[],"tags":["编程札记"]},{"title":"时间和日期","url":"https://blog.ranchocooper.com/2017/10/03/python-stdlib-04dates-and-times/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p>不同于int、float和str，Python没有包含对应日期和时间的内置类型，不过提供了3个相应模块，可以采用多种表示管理日期和时间值。</p>\n<ul>\n<li><code>time</code>模块由底层C库提供与时间相关的函数。它包含一些函数用于获取时钟时间和处理器运行时间，还提供了基本的解析和字符串格式化工具。</li>\n<li><code>datetime</code>模块为日期、时间以及日期时间提供了一个高层接口。datetime中的类支持算术、比较和时区配置。</li>\n<li><code>calendar</code>模块可以创建周、月和年的格式化表示。它还可以计算重复事件、给定日期是周几，以及其他基于日历的值。</li>\n</ul>\n<h1 id=\"时钟时间-time\"><a href=\"#时钟时间-time\" class=\"headerlink\" title=\"时钟时间 - time\"></a>时钟时间 - time</h1><p><code>time</code>模块提供了一些用于管理日期和时间的C库函数。由于它绑定到底层C实现，一些细节(比如纪元开始时间和支持的最大日期)会特定于特定平台。</p>\n<h2 id=\"壁挂钟时间\"><a href=\"#壁挂钟时间\" class=\"headerlink\" title=\"壁挂钟时间\"></a>壁挂钟时间</h2><p><code>time</code>函数是time模块的核心函数之一，它会返回一个从纪元开始至今的浮点秒数。浮点数的表示对时间的存储和比较很有用，但是想要生成人类刻度的表示就差强人意了。如果你想记录或者打印时间，<code>ctime</code>可能更有用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\">t = time.time()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.ctime())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.ctime(t + <span class=\"number\">20</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理器时间\"><a href=\"#处理器时间\" class=\"headerlink\" title=\"处理器时间\"></a>处理器时间</h2><p><code>clock</code>的返回值反映了程序的实际使用CPU(运行)时间，应当用于性能测试、基准测试等。值得注意的是，如果程序什么也没做，这时候处理器时钟是不会走动的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s %0.2f %0.2f&quot;</span> % (time.ctime(), time.time(), time.clock()))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sleeping&quot;</span>, i)</span><br><span class=\"line\">    time.sleep(i)</span><br></pre></td></tr></table></figure>\n<p>在这个例子里，每次循环仅仅进入睡眠，几乎没做什么工作。这样一来，两个挂壁时间在增加，而clock始终没发生变化。</p>\n<h2 id=\"时间组成\"><a href=\"#时间组成\" class=\"headerlink\" title=\"时间组成\"></a>时间组成</h2><p>有些情况下需要将时间存储为过去了多少秒，还有的情况需要访问一个日期的各个字段(年、月等)。time模块定义了<code>struct_time</code>来维护日期和时间值。gmtime函数会返回UTC格式的当前时间，而localtime则会返回应用了当前时区的当前时间。mktime会取一个struct_time实例，并将其转换回浮点数表示。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show_struct</span>(<span class=\"params\">t</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_year: &#x27;</span>, t.tm_year)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_mon: &#x27;</span>, t.tm_mon)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_mday: &#x27;</span>, t.tm_mday)       <span class=\"comment\"># day in month</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_hour: &#x27;</span>, t.tm_hour)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_min: &#x27;</span>, t.tm_min)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_sec: &#x27;</span>, t.tm_sec)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_wday: &#x27;</span>, t.tm_wday)       <span class=\"comment\"># day in week</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_yday: &#x27;</span>, t.tm_yday)       <span class=\"comment\"># day in year</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_isdst: &#x27;</span>, t.tm_isdst)     <span class=\"comment\"># DST flag</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_zone: &#x27;</span>, t.tm_zone)       <span class=\"comment\"># local time zone</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tm_gmtoff: &#x27;</span>, t.tm_gmtoff)</span><br><span class=\"line\"></span><br><span class=\"line\">show_struct(time.gmtime())</span><br><span class=\"line\">show_struct(time.localtime())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;mktime: &#x27;</span>, time.mktime(time.localtime()))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理时区\"><a href=\"#处理时区\" class=\"headerlink\" title=\"处理时区\"></a>处理时区</h2><p>确定当前时间的函数有一个前提，即已经设置了时区。时区的设置可能由应用程序设置，也可以使用系统的默认时区。修改时区不会改变具体的当前时间，只是改变了当前时间的表示(仅仅做了转换)。</p>\n<p>要改变时区，需要设置环境变量TZ，然后调用tzset。设置时区时可以指定很多细节，甚至详细到日光的开始和结束时间。不过，通常的做法是使用时区名，并由底层库推导出其他信息。下面我们来简单地修改时区</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show_zone_info</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;TZ: &#x27;</span>, os.environ.get(<span class=\"string\">&#x27;TZ&#x27;</span>, <span class=\"string\">&#x27;(not set yet)&#x27;</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tzname: &#x27;</span>, time.tzname)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;zone: %d (%d)&#x27;</span> % (time.timezone, time.timezone / <span class=\"number\">3600</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;DST: &#x27;</span>, time.daylight)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Time: &#x27;</span>, time.ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Default:&#x27;</span>)</span><br><span class=\"line\">show_zone_info()</span><br><span class=\"line\"></span><br><span class=\"line\">ZONES = [<span class=\"string\">&#x27;GMT&#x27;</span>, <span class=\"string\">&#x27;Europe/Amsterdam&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> zone <span class=\"keyword\">in</span> ZONES:</span><br><span class=\"line\">    os.environ[<span class=\"string\">&#x27;TZ&#x27;</span>] = zone</span><br><span class=\"line\">    time.tzset()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(zone, <span class=\"string\">&#x27;: &#x27;</span>)</span><br><span class=\"line\">    show_zone_info()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析和格式化时间\"><a href=\"#解析和格式化时间\" class=\"headerlink\" title=\"解析和格式化时间\"></a>解析和格式化时间</h2><p>工具函数strptime(parsed)和strftime(formatted)可以在struct_time和是兼职字符串表示之间转换</p>\n<h1 id=\"日期和时间值管理-datetime\"><a href=\"#日期和时间值管理-datetime\" class=\"headerlink\" title=\"日期和时间值管理 - datetime\"></a>日期和时间值管理 - datetime</h1><h2 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h2><p>时间值用<code>time</code>类表示，time实例包含hour、minute、second和microsecond属性，还可以包含时区信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\">t = datetime.time(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t.hour)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t.minute)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t.second)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t.microsecond)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t.tzinfo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(datetime.time.<span class=\"built_in\">min</span>, datetime.time.<span class=\"built_in\">max</span>, datetime.time.resolution)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h2><p>日历日期值用<code>date</code>类表示，date实例包含year、month和day属性。使用<code>today</code>类方法很容易能穿件一个表示当前日期的日期实例。today类的<code>ctime</code>方法可以获得格式化的时间表示，而<code>timetuple</code>则返回today实例的struct_time结构。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\">today = datetime.date.today()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(today)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;ctime: &#x27;</span>, today.ctime())</span><br><span class=\"line\">tt = today.timetuple()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;tuple: tm_year = &#x27;</span>, tt.tm_year)</span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>datetime.date.fromordinal</code>和<code>datetime.date.fromtimestamp</code>分别可以将天数和时戳转换成对应的日期结构。</p>\n<h2 id=\"timedelta\"><a href=\"#timedelta\" class=\"headerlink\" title=\"timedelta\"></a>timedelta</h2><p>通过对两个datetime对象使用算数运算，或者结合使用<code>datetime</code>和<code>timedelta</code>，可以根据得到将来或过去的日期。比如，两个日期相减可以生成一个timedelta，对日期进行timedelta运算可以生成另一个日期。</p>\n<p>实际上，通过<code>datetime.datetime.combine</code>方法，你可以将一个datetime.date实例和一个datetime.time相组合。</p>\n<h1 id=\"处理日期-calendar\"><a href=\"#处理日期-calendar\" class=\"headerlink\" title=\"处理日期 - calendar\"></a>处理日期 - calendar</h1><p>calendar模块实现了一些类来处理日期，管理面向年、月和周的值。通过prmonth方法可以生成一个月的格式化的文本日历输出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> calendar</span><br><span class=\"line\"></span><br><span class=\"line\">c = calendar.TextCalendar(calendar.SUNDAY)      <span class=\"comment\"># 配置每周的起始日</span></span><br><span class=\"line\">c.prmonth(<span class=\"number\">2017</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["编程札记","Python标准库"]},{"title":"固定类型数据序列 - Array","url":"https://blog.ranchocooper.com/2017/10/01/python-stdlib-02array/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p><code>array</code>模块定义了一个序列数据结构，看起来它和list非常相似，只不过所有成员都必须是相同的基本类型。</p>\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>array实例化时可以提供一个参数来描述允许哪种数据类型，还有一个初始的数据序列存储在数组中。<br>下面的例子将数组配置为<code>Unicode character</code>序列，并用一个简单的字符串来初始化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> array</span><br><span class=\"line\"><span class=\"keyword\">import</span> binascii</span><br><span class=\"line\"></span><br><span class=\"line\">s = <span class=\"string\">&#x27;this is the array.&#x27;</span></span><br><span class=\"line\">a = array.array(<span class=\"string\">&#x27;u&#x27;</span>, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;as string: &#x27;</span>, s)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;as array: &#x27;</span>, a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;as hex: &#x27;</span>, binascii.hexlify(a))</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"处理数组\"><a href=\"#处理数组\" class=\"headerlink\" title=\"处理数组\"></a>处理数组</h1><p>类似其他的Python序列，可以采用同样的方式扩展和处理array。支持的操作包括末尾插入元素，分片以及迭代。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> array</span><br><span class=\"line\"><span class=\"keyword\">import</span> pprint</span><br><span class=\"line\"></span><br><span class=\"line\">a = array.array(<span class=\"string\">&#x27;i&#x27;</span>, <span class=\"built_in\">range</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;init: &#x27;</span>, a)</span><br><span class=\"line\"></span><br><span class=\"line\">a.extend(<span class=\"built_in\">range</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;extended: &#x27;</span>, a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;slice: &#x27;</span>, a[<span class=\"number\">2</span>:<span class=\"number\">5</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;iterator: &#x27;</span>, <span class=\"built_in\">list</span>(<span class=\"built_in\">enumerate</span>(a)))</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组与文件\"><a href=\"#数组与文件\" class=\"headerlink\" title=\"数组与文件\"></a>数组与文件</h1><p>可以使用高效的内置文件读写方法将数组呢哦荣写入文件或者从文件读入数组。<br>下面的例子展示了直接从二进制文件读取原始数据，将它读入一个新的数组，并把字节转换为适当的类型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> array</span><br><span class=\"line\"><span class=\"keyword\">import</span> binascii</span><br><span class=\"line\"><span class=\"keyword\">import</span> tempfile</span><br><span class=\"line\"></span><br><span class=\"line\">a = array.array(<span class=\"string\">&#x27;i&#x27;</span>, <span class=\"built_in\">range</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;A1: &#x27;</span>, a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># write the array of numbers to a temporary file</span></span><br><span class=\"line\">output = tempfile.NamedTemporaryFile()</span><br><span class=\"line\"></span><br><span class=\"line\">a.tofile(output.file)       <span class=\"comment\"># must pass an *actual* file</span></span><br><span class=\"line\">output.flush()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># read the raw data</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(output.name, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">input</span>:</span><br><span class=\"line\">    raw_data = <span class=\"built_in\">input</span>.read()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Raw contents: &#x27;</span>, binascii.hexlify(raw_data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#read the data into an array</span></span><br><span class=\"line\">    <span class=\"built_in\">input</span>.seek(<span class=\"number\">0</span>)</span><br><span class=\"line\">    a2 = array.array(<span class=\"string\">&#x27;i&#x27;</span>)</span><br><span class=\"line\">    a2.fromfile(<span class=\"built_in\">input</span>, <span class=\"built_in\">len</span>(a))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;A2: &#x27;</span>, a2)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"候选字节顺序\"><a href=\"#候选字节顺序\" class=\"headerlink\" title=\"候选字节顺序\"></a>候选字节顺序</h1><p>如果数组中的数据没有采用固有的字节顺序，或者在发送到一个采用不同字节顺序的系统(这通常发生在网络传输中)之前需要交换顺序，可以通过<code>byteswap</code>方法来交换C数组中的字节顺序，比在Python中循环处理数据要高效很多。</p>\n","categories":[],"tags":["编程札记","Python标准库"]},{"title":"容器数据类型 - Collections","url":"https://blog.ranchocooper.com/2017/10/01/python-stdlib-02collections/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p><code>collections</code>模块包含多种数据结构的实现，扩展了其他模块中的相应结构。</p>\n<ul>\n<li>Counter：计数器</li>\n<li>defaultdict：带有默认值的字典。</li>\n<li>OrderedDict：记忆元素顺序的有序字典</li>\n<li>deque：双端队列，允许从任意一端增加或删除元素。</li>\n<li>namedtuple：生成可以使用名字来访问元素内容的tuple子类</li>\n</ul>\n<h1 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h1><p>Counter作为一个容器，可以跟踪相同的值增加了多少次。Counter支持3种形式的初始化：调用Counter构造函数时提供元素序列或者一个包含键和技术的字典，还可以使用关键字参数将字符串名映射到计数。(默认行为会按照key来排序)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"></span><br><span class=\"line\">Counter([<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>])</span><br><span class=\"line\">Counter(&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">3</span>&#125;)</span><br><span class=\"line\">Counter(a=<span class=\"number\">2</span>, b=<span class=\"number\">1</span>, c=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># got the same results</span></span><br><span class=\"line\"><span class=\"comment\"># Counter(&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 1, &#x27;c&#x27;: 3&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不提供任何参数，可以构造一个空的Counter，然后通过<code>update</code>方法填充。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"></span><br><span class=\"line\">c = Counter()</span><br><span class=\"line\"><span class=\"comment\"># Counter()</span></span><br><span class=\"line\"></span><br><span class=\"line\">c.update(<span class=\"string\">&#x27;abbcccdddd&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># Counter(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;:2, &#x27;c&#x27;: 3, &#x27;d&#x27;:4&#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">c.update(a=<span class=\"number\">2</span>, d=<span class=\"number\">5</span>, e=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># Counter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;:2, &#x27;c&#x27;: 3, &#x27;d&#x27;:9, &#x27;e&#x27;: 1&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<p>一旦填充了Counter，可以通过字典API来获取它的值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections importCounter</span><br><span class=\"line\"></span><br><span class=\"line\">c = Counter(<span class=\"string\">&#x27;abcdaab&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> <span class=\"string\">&#x27;abcde&#x27;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#123;0&#125;: &#123;1&#125;&#x27;</span>.<span class=\"built_in\">format</span>(letter, c[letter]))</span><br></pre></td></tr></table></figure>\n<p>对于未知的元素，Counter不会产生KeyError。如果在输入中没有找到某个值，其计数为0。<br><code>elements</code>方法返回一个迭代器，返回Counter记录的所有元素，不过不能保证元素的顺序不变。<br><code>most_common</code>方法生成一个序列，返回计数最大的N项元素，如果不提供参数，则会按频度排序返回所有列表。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> letter, count <span class=\"keyword\">in</span> c.most_common(<span class=\"number\">3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(letter, count))</span><br></pre></td></tr></table></figure>\n\n<p>另外，Counter实例还支持算数和集合操作。每次执行一个操作会生成一个新的Counter，并且计数为0或者为负数的元素会被删除。</p>\n<h1 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h1><p>内建字典包含<code>setdefault</code>方法来获取默认值，而defaultdict会在初始化容器时就让调用者提前指定默认值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"></span><br><span class=\"line\">d1 = defaultdict(<span class=\"built_in\">int</span>)</span><br><span class=\"line\">d2 = defaultdict(partial(<span class=\"built_in\">int</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">d3 = defaultdict(partial(defaultdict, partial(<span class=\"built_in\">int</span>, <span class=\"number\">3</span>)))</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h1><p>OrderedDict其实是字典的子类，它可以记住往字典中增加元素的顺序</p>\n<p>需要注意的时，OrderedDict在检查相等性时，除了查看其内容，也会考虑元素增加的顺序</p>\n<h1 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h1><p>双端队列支持从任意一端增加和删除元素。栈和队列实际上就是双端队列的退化形式，其输入和输出都限制在一端。由于deque是一种序列容器，因此同样支持list的一些操作，如用<code>__getitem__</code>检查内容，确定长度，以及通过匹配标识从序列中删除某元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\">d = deque(<span class=\"string\">&#x27;abcdefg&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(d))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d[-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">d.remove(<span class=\"string\">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>从左端或右端填充数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d1 = deque()</span><br><span class=\"line\">d1.extend(<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\">d1.append(<span class=\"string\">&#x27;efg&#x27;</span>)</span><br><span class=\"line\">d1.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">d2 = deque()</span><br><span class=\"line\">d2.extendleft(<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\">d2.appendleft(<span class=\"string\">&#x27;efg&#x27;</span>)</span><br><span class=\"line\">d2.popleft()</span><br></pre></td></tr></table></figure>\n\n<p>还可以按任意方向<strong>旋转</strong>从而跳过一些元素。<br>你可以形象地把deque中的元素想象成是刻在拨号盘上数字，当参数为负数，则逆时针(左旋)转动，否则为顺时针转动(右旋)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d.rotate(<span class=\"number\">2</span>)</span><br><span class=\"line\">d.rotate(-<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h1><p>内建tuple使用数值索引来访问成员，一旦tuple中的字段变多，而且在代码实现中，可能元组的构造和使用相距很远，就很容易导致错误。namedtuple除了指定数值索引外，还回指定名字。在内存使用方面，namedtupel和内建元组同样高效。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</span><br><span class=\"line\"></span><br><span class=\"line\">person = namedtuple(<span class=\"string\">&#x27;person&#x27;</span>, <span class=\"string\">&#x27;name age gender&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;type of person: &#x27;</span>, <span class=\"built_in\">type</span>(person))</span><br><span class=\"line\"></span><br><span class=\"line\">rancho = person(name=<span class=\"string\">&#x27;rancho&#x27;</span>, age=<span class=\"number\">20</span>, gender=<span class=\"string\">&#x27;male&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(rancho)</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，namedtuple定义字段时是不允许重复的，如果非要这么做，可以将<code>rename</code>参数设置为<code>True</code></p>\n","categories":[],"tags":["编程札记","Python标准库"]},{"title":"『译』测试固件那些事","url":"https://blog.ranchocooper.com/2017/07/26/pytest-fixtures/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><p>测试固件的目的是提供一个固定的基线。在此基础上，测试可以可靠且反复地执行。pytest fixture对典型的xUnit风格的setup&#x2F;teardown功能提供了显著的改进。</p>\n<h1 id=\"Fixtures-as-Function-arguments\"><a href=\"#Fixtures-as-Function-arguments\" class=\"headerlink\" title=\"Fixtures as Function arguments\"></a>Fixtures as Function arguments</h1><p>通过参数传递，测试函数能够接收固件对象。pytest fixture基于setup&#x2F;teardown等xUnit风格上做了令人兴奋的改进：</p>\n<ul>\n<li>固件具有显式名称，通过在参数列表中声明它们，便能在测试函数、模块、类或整个项目中激活。</li>\n<li>固件以模块化的方式实现，因为每个固件都会触发特定的功能，它自己也可以使用其他的固件。</li>\n<li>固件管理十分灵活，从简单的单元到复杂的功能测试，并且允许根据配置和组件选项将固件参数化，并在类，模块或整个测试会话中重用固件。</li>\n</ul>\n<p>此外，pytest继续支持经典的xUnit风格设置。你可以混合使用这两种风格，也可以逐步地从经典到新风格。<br>另外，基于unittest和nosed的项目也能很容易扩展为pytest</p>\n<h1 id=\"Fixtures-as-Function-arguments-1\"><a href=\"#Fixtures-as-Function-arguments-1\" class=\"headerlink\" title=\"Fixtures as Function arguments\"></a>Fixtures as Function arguments</h1><p>测试函数可以通过传递参数来接收固件对象。对于每个参数名称，都对应了该名称的固件函数提供的固件对象。固件的注册是通过 <code>@pytest.fixture</code>来注册的。让我们看一个简单的包含fixture和测试函数的测试模块:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># content of ./test_smtpsimple.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">smtp</span>():</span><br><span class=\"line\">    <span class=\"keyword\">import</span> smtplib</span><br><span class=\"line\">    <span class=\"keyword\">return</span> smtplib.SMTP(<span class=\"string\">&quot;smtp.gmail.com&quot;</span>, <span class=\"number\">587</span>, timeout=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_ehlo</span>(<span class=\"params\">smtp</span>):</span><br><span class=\"line\">    response, msg = smtp.ehlo()</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> response == <span class=\"number\">250</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"number\">0</span> <span class=\"comment\"># for demo purposes</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里， 我们在<code>test_ehlo</code>测试函数的参数列表中显式传入了所需的 <code>smtp</code>固件。pytest会发现并调用被标记为<code>smtp</code>的<code>@pytest.fixture</code></p>\n<h2 id=\"Sharing-a-fixture-across-tests-in-a-module-or-class-or-session\"><a href=\"#Sharing-a-fixture-across-tests-in-a-module-or-class-or-session\" class=\"headerlink\" title=\"Sharing a fixture across tests in a module or class or session\"></a>Sharing a fixture across tests in a module or class or session</h2><p>如果你想复用声明的fixture，只需在声明时显式指定其作用域即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&#x27;function&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_only_modular_smtp</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&#x27;module&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">module_shared_smtp</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&#x27;class&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">class_shared_smtp</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&#x27;session&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">whole_testing_shared_smtp</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Fixture-finalization-x2F-executing-teardown-code\"><a href=\"#Fixture-finalization-x2F-executing-teardown-code\" class=\"headerlink\" title=\"Fixture finalization&#x2F; executing teardown code\"></a>Fixture finalization&#x2F; executing teardown code</h1><p>不同于unittest中通过定义teardown函数的方式，pytest中只需通过<code>yield</code>关键字就能完成teardown工作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;module&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">smtp</span>():</span><br><span class=\"line\">    smtp = smtplib.SMTP(<span class=\"string\">&quot;smtp.gmail.com&quot;</span>, <span class=\"number\">587</span>, timeout=<span class=\"number\">5</span>)  <span class=\"comment\"># do something</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> smtp  <span class=\"comment\"># provide the fixture value</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;teardown smtp&quot;</span>)    <span class=\"comment\"># do the teardown thing</span></span><br><span class=\"line\">    smtp.close()</span><br></pre></td></tr></table></figure>\n\n<p>如果你的teardown包含复杂的工作，也可以选择下面这种方式。<br>通过向固件传入<code>request</code>对象，便能内省测试上下文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;module&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">smtp</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    smtp = smtplib.SMTP(<span class=\"string\">&quot;smtp.gmail.com&quot;</span>, <span class=\"number\">587</span>, timeout=<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">fin</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span> (<span class=\"string\">&quot;teardown smtp&quot;</span>)</span><br><span class=\"line\">        smtp.close()</span><br><span class=\"line\">    request.addfinalizer(fin)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> smtp  <span class=\"comment\"># provide the fixture value</span></span><br></pre></td></tr></table></figure>\n<p>不同于第一种方式，<code>addfinalizer</code>方法支持注册多个finalizer并且能保证代码一定被执行(yield只是一种语法糖，并不能保证这一点)</p>\n<h1 id=\"Fixtures-can-introspect-the-requesting-test-context\"><a href=\"#Fixtures-can-introspect-the-requesting-test-context\" class=\"headerlink\" title=\"Fixtures can introspect the requesting test context\"></a>Fixtures can introspect the requesting test context</h1><p>如刚才展示的，<code>request</code>对象允许在定义固件时访问其上下文。假设我们的smtp需要动态地获取服务器，它的单元测试代码可能如下所示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smtpserver = <span class=\"string\">&#x27;mail.python.org&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_showhelo</span>(<span class=\"params\">smtp</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"number\">0</span>, smtp.helo()</span><br></pre></td></tr></table></figure>\n\n<p>在定义固件时，通过<code>request</code>便能动态获取到这个值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&#x27;module&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">smtp</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    server = <span class=\"built_in\">getattr</span>(request.module, <span class=\"string\">&#x27;smtpserver&#x27;</span>, <span class=\"string\">&#x27;smtp.gmail.com&#x27;</span>) <span class=\"comment\"># default value</span></span><br><span class=\"line\">    smtp = smtplib.SMTP(server, <span class=\"number\">587</span>, timeout=<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> smtp</span><br><span class=\"line\">    <span class=\"built_in\">print</span> (<span class=\"string\">&quot;finalizing %s (%s)&quot;</span> % (smtp, server))</span><br><span class=\"line\">    smtp.close()</span><br></pre></td></tr></table></figure>\n\n","categories":[],"tags":["编程札记","pytest"]},{"title":"MySQL架构","url":"https://blog.ranchocooper.com/2017/07/22/mysql-architecture/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><blockquote>\n<p>MySQL不够完美，但却足够灵活。</p>\n</blockquote>\n<p>MySQL最与众不同的特性是它的存储引擎架构，它将查询处理(Query Processing)于其他子系统单独隔离。这种处理和存储分离的设计可以在使用时根据环境特性来按需选择数据存储的方式。</p>\n<h1 id=\"逻辑架构\"><a href=\"#逻辑架构\" class=\"headerlink\" title=\"逻辑架构\"></a>逻辑架构</h1><p><img src=\"/mysql-architecture.jpg\" alt=\"逻辑架构\"></p>\n<p>可以看到，其架构分为三层。三层的功能分别为：</p>\n<ul>\n<li>服务层：连接处理，授权认证，安全等大多数基于网络的工具都会提供的功能。</li>\n<li>核心层：查询解析，分析优化，缓存，以及跨存储引擎的功能(存储过程，触发器，视图等)。</li>\n<li>引擎层：存储引擎。类似各种文件系统，不同的存储引擎都有各自的优缺点。不同引擎间不会相互通信，仅仅响应上层的服务请求。引擎接口对外是透明的。</li>\n</ul>\n<p>每个客户端连接都会在服务器进程中拥有一个线程，在该连接中进行的查询操作只会在这个单独的线程环境中执行。5.5之后支持线程池插件，可以通过少量线程来处理大量连接。响应一个查询请求时，MySQL会解析查询，创建内部解析树，并对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择适合的索引。对SELECT查询，会在解析之前检查查询缓存(Query Cache)。如果能找到对应的查询，便不再进行查询解析，优化和执行等过程，直接返回查询缓存中的结果。</p>\n<h1 id=\"并发控制\"><a href=\"#并发控制\" class=\"headerlink\" title=\"并发控制\"></a>并发控制</h1><p>当有多个查询在同一时刻修改数据，就会产生并发控制的问题。这个问题通过实现共享锁和排他锁即可解决，即读锁和写锁。读锁是互不干扰的，即保证了多个查询可以同时读取同一个资源。而写锁则会则塞其他读锁和写锁对资源的访问，这样才能避免同时写入数据的发生。</p>\n<p>实现锁带来的另一个问题是加锁需要耗费额外资源，获得锁，检查锁，释放锁等操作，都会增加系统的开销。锁粒度越小，系统的并发程度就越高。良好的锁策略，应该是在锁开销和数据安全性之间寻求平衡。</p>\n<p>表锁和行锁是数据库中常见的两种锁策略。</p>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>一个运行良好的事务处理系统，应该具备ACID特性。</p>\n<ul>\n<li>原子性(atomicity)：事务是最小的工作单元，其中的操作要么全部执行，要么中途失败，全部回滚。</li>\n<li>一致性(consistency)：保证事务状态的独立，不存在逻辑上的混杂。</li>\n<li>隔离性(isolation)：在事务完成之前，对外不可见。</li>\n<li>持久性(durability)：保证事务一旦提交，其修改便能存至数据库。</li>\n</ul>\n<p>SQL标准中定义了四种隔离级别：</p>\n<ul>\n<li>未提交读：修改而未提交的事务，对外可见。(脏读)</li>\n<li>提交读：当事务提交后，其修改才对外可见。大部分数据库的默认隔离级别。(不可重复读，在同一事务中先后执行同样的查询，结果可能不一致)</li>\n<li>可重复读：保证在同一事务多次读取同样记录的结果是一致的。(解决了脏读，但无法解决幻读)</li>\n<li>可串行化：最高级别的隔离，通过强制事务串行执行，避免了幻读。实际中一般不考虑。</li>\n</ul>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>InnoDB是MySQL的默认事务型引擎，此外它还内建多种引擎，支持插件式的引擎API。</p>\n<p>面对不同需求和应用场景要选择合适引擎。</p>\n","categories":[],"tags":["编程札记","高性能MySQL"]},{"title":"伯爵修炼的地方","url":"https://blog.ranchocooper.com/2017/07/20/hello-world/","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>伯爵，浙江人士。</p>\n<p>不喜欢在网络上实名，常用英文名Rancho，取自印度电影🎬《三傻大闹宝莱坞》中男主角的名字。</p>\n<p>中学酷爱物理与哲学，高考后就读计算机科学与技术。彼时内心的憧憬，是<strong>科技改变世界</strong>。</p>\n<p>大一刚入校，吴军博士的《浪潮之巅》与李开复博士的《做最好的自己》深深激励着自己。转眼四年已过，毕业后便走上了程序员的不归路。热爱开源，崇尚黑客。</p>\n<h1 id=\"正\"><a href=\"#正\" class=\"headerlink\" title=\"正\"></a>正</h1><p>2016年四月，伯爵搭建了他的<a href=\"https://rancho1110.com/\">第一个博客</a>。</p>\n<p>时隔一年，伯爵已告别学生时代，正式迈入社会，开启了人生中全新的旅途。入职后配备了人生首部Mac Book Pro，从此也告别了ArchLinux的时代。作为CS科班出身的码农，本该尝试从零到一构建自己的专属Blog。考虑到时间成本，最终选择了<a href=\"https://hexo.io/\">Hexo</a> + <a href=\"https://pages.github.com/\">Github Page</a>的博客方案。</p>\n<p>选择理由：</p>\n<ul>\n<li>优雅的<strong>MarkDown</strong>写作体验</li>\n<li>Hexo静态博客框架，管理起来高效便捷</li>\n</ul>\n<p>考虑到GitHub国内网络访问普遍较慢，因此部署到<a href=\"https://pages.coding.net/\">Coding</a>上。</p>\n<h1 id=\"后\"><a href=\"#后\" class=\"headerlink\" title=\"后\"></a>后</h1><p>2017年七月，伯爵成为后端工程师。工作之余，重新搭建了博客。<br>一来记录编程与技术，二来找个写字的地方。</p>\n<p>不定期更新编程和技术的文章，偶尔发文记录成长与生活。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> UmFuY2hvIENvb3Blcgo= | <span class=\"built_in\">base64</span> -d</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["随笔"]},{"title":"","url":"https://blog.ranchocooper.com/404.html","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\">","categories":[],"tags":[]},{"title":"","url":"https://blog.ranchocooper.com/google912aba6a170c1279.html","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\">\ngoogle-site-verification: google912aba6a170c1279.html","categories":[],"tags":[]},{"title":"Archives","url":"https://blog.ranchocooper.com/archives/index.html","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\">","categories":[],"tags":[]},{"title":"About","url":"https://blog.ranchocooper.com/about/index.html","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\"><blockquote>\n<p>孤独旅行客，终生学习者。<br>主业程序员，副业文艺男。</p>\n</blockquote>\n<ul>\n<li>现状: Backend Engineer</li>\n<li>产地: CQUPT</li>\n<li>品种: 计算机科学与技术</li>\n<li>爱好: 魔方, 音乐, 羽毛球</li>\n<li>追剧: 秦时明月, 生活大爆炸, 权力的游戏</li>\n<li>最喜欢的专业书籍: 深入理解计算机系统</li>\n<li>最喜欢的社科书籍: 站在两个世界的边缘</li>\n</ul>\n<br>\n","categories":[],"tags":[]},{"title":"Tags","url":"https://blog.ranchocooper.com/tags/index.html","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css\">","categories":[],"tags":[]}]